import { Duration } from '../../../core';
import { IMetric, MetricConfig, MetricExpressionConfig, MetricStatConfig } from '../metric-types';
/**
 * Return a unique string representation for this metric.
 *
 * Can be used to determine as a hash key to determine if 2 Metric objects
 * represent the same metric. Excludes rendering properties.
 */
export declare function metricKey(metric: IMetric): string;
/**
 * Return the period of a metric
 *
 * For a stat metric, return the immediate period.
 *
 * For a math expression metric, all metrics used in it have been made to have the
 * same period, so we return the period of the first inner metric.
 *
 * For a search expression metric, return the period of the search expression.
 */
export declare function metricPeriod(metric: IMetric): Duration;
/**
 * Given a metric object, inspect it and call the correct function for the type of output
 *
 * In addition to the metric object itself, takes a callback object with three
 * methods, to be invoked for the particular type of metric.
 *
 * If the metric represent a metric query (nominally generated through an
 * instantiation of `Metric` but can be generated by any class that implements
 * `IMetric`) a particular field in its `toMetricConfig()` output will be set
 * (to wit, `metricStat`) and the `withStat()` callback will be called with
 * that object.
 *
 * If the metric represents a math expression (usually by instantiating `MathExpression`
 * but users can implement `IMetric` arbitrarily) the `mathExpression` field
 * will be set in the object returned from `toMetricConfig` and the callback
 * called `withMathExpression` will be applied to that object.
 *
 * If the metric represents a search expression (usually by instantiating `SearchExpression`
 * but users can implement `IMetric` arbitrarily) the `searchExpression` field
 * will be set in the object returned from `toMetricConfig` and the callback
 * called `withSearchExpression` will be applied to that object.
 *
 * Will return the values returned by the callbacks.
 *
 * To be used as such:
 *
 * ```ts
 * const ret = dispatchMetric(someMetric, {
 *   withStat(stat) {
 *     // do something with stat
 *     return 1;
 *   },
 *   withMathExpression(mathExpr) {
 *     // do something with math expression
 *     return 2;
 *   },
 *   withSearchExpression(searchExpr) {
 *     // do something with search expression
 *     return 3;
 *   },
 * });
 * ```
 *
 * This function encapsulates some type analysis that would otherwise have to be
 * repeated in all places where code needs to make a distinction on the type
 * of metric object that is being passed.
 */
export declare function dispatchMetric<A, B, C>(metric: IMetric, fns: {
    withStat: (x: MetricStatConfig, c: MetricConfig) => A;
    withMathExpression: (x: MetricExpressionConfig, c: MetricConfig) => B;
    withSearchExpression: (x: MetricExpressionConfig, c: MetricConfig) => C;
}): A | B | C;
