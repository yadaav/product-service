"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InitTemplate = void 0;
exports.cliInit = cliInit;
exports.expandPlaceholders = expandPlaceholders;
exports.availableInitTemplates = availableInitTemplates;
exports.availableInitLanguages = availableInitLanguages;
exports.printAvailableTemplates = printAvailableTemplates;
exports.currentlyRecommendedAwsCdkLibFlags = currentlyRecommendedAwsCdkLibFlags;
const childProcess = require("child_process");
const path = require("path");
const toolkit_lib_1 = require("@aws-cdk/toolkit-lib");
const chalk = require("chalk");
const fs = require("fs-extra");
const init_hooks_1 = require("./init-hooks");
const root_dir_1 = require("../../cli/root-dir");
const version_1 = require("../../cli/version");
const util_1 = require("../../util");
const language_1 = require("../language");
/* eslint-disable @typescript-eslint/no-var-requires */ // Packages don't have @types module
// eslint-disable-next-line @typescript-eslint/no-require-imports
const camelCase = require('camelcase');
// eslint-disable-next-line @typescript-eslint/no-require-imports
const decamelize = require('decamelize');
/**
 * Initialize a CDK package in the current directory
 */
async function cliInit(options) {
    const ioHelper = options.ioHelper;
    const canUseNetwork = options.canUseNetwork ?? true;
    const generateOnly = options.generateOnly ?? false;
    const workDir = options.workDir ?? process.cwd();
    // Show available templates if no type and no language provided (main branch logic)
    if (!options.fromPath && !options.type && !options.language) {
        await printAvailableTemplates(ioHelper);
        return;
    }
    // Step 1: Load template
    let template;
    if (options.fromPath) {
        template = await loadLocalTemplate(options.fromPath, options.templatePath);
    }
    else {
        template = await loadBuiltinTemplate(ioHelper, options.type, options.language);
    }
    // Step 2: Resolve language
    const language = await resolveLanguage(ioHelper, template, options.language, options.type);
    // Step 3: Initialize project following standard process
    await initializeProject(ioHelper, template, language, canUseNetwork, generateOnly, workDir, options.stackName, options.migrate, options.libVersion);
}
/**
 * Load a local custom template from file system path
 * @param fromPath - Path to the local template directory or multi-template repository
 * @param templatePath - Optional path to a specific template within a multi-template repository
 * @returns Promise resolving to the loaded InitTemplate
 */
async function loadLocalTemplate(fromPath, templatePath) {
    try {
        let actualTemplatePath = fromPath;
        // If templatePath is provided, it's a multi-template repository
        if (templatePath) {
            actualTemplatePath = path.join(fromPath, templatePath);
            if (!await fs.pathExists(actualTemplatePath)) {
                throw new toolkit_lib_1.ToolkitError(`Template path does not exist: ${actualTemplatePath}`);
            }
        }
        const template = await InitTemplate.fromPath(actualTemplatePath);
        if (template.languages.length === 0) {
            // Check if this might be a multi-template repository
            if (!templatePath) {
                const availableTemplates = await findPotentialTemplates(fromPath);
                if (availableTemplates.length > 0) {
                    throw new toolkit_lib_1.ToolkitError('Use --template-path to specify which template to use.');
                }
            }
            throw new toolkit_lib_1.ToolkitError('Custom template must contain at least one language directory');
        }
        return template;
    }
    catch (error) {
        const displayPath = templatePath ? `${fromPath}/${templatePath}` : fromPath;
        throw new toolkit_lib_1.ToolkitError(`Failed to load template from path: ${displayPath}. ${error.message}`);
    }
}
/**
 * Load a built-in template by name
 */
async function loadBuiltinTemplate(ioHelper, type, language) {
    const templateType = type || 'default'; // "default" is the default type (and maps to "app")
    const template = (await availableInitTemplates()).find((t) => t.hasName(templateType));
    if (!template) {
        await printAvailableTemplates(ioHelper, language);
        throw new toolkit_lib_1.ToolkitError(`Unknown init template: ${templateType}`);
    }
    return template;
}
/**
 * Resolve the programming language for the template
 * @param ioHelper - IO helper for user interaction
 * @param template - The template to resolve language for
 * @param requestedLanguage - User-requested language (optional)
 * @param type - The template type name for messages
 * @default undefined
 * @returns Promise resolving to the selected language
 */
async function resolveLanguage(ioHelper, template, requestedLanguage, type) {
    return (async () => {
        if (requestedLanguage) {
            return requestedLanguage;
        }
        if (template.languages.length === 1) {
            const templateLanguage = template.languages[0];
            // Only show auto-detection message for built-in templates
            if (template.templateType !== TemplateType.CUSTOM) {
                await ioHelper.defaults.warn(`No --language was provided, but '${type || template.name}' supports only '${templateLanguage}', so defaulting to --language=${templateLanguage}`);
            }
            return templateLanguage;
        }
        await ioHelper.defaults.info(`Available languages for ${chalk.green(type || template.name)}: ${template.languages.map((l) => chalk.blue(l)).join(', ')}`);
        throw new toolkit_lib_1.ToolkitError('No language was selected');
    })();
}
/**
 * Find potential template directories in a multi-template repository
 * @param repositoryPath - Path to the repository root
 * @returns Promise resolving to array of potential template directory names
 */
async function findPotentialTemplates(repositoryPath) {
    try {
        const entries = await fs.readdir(repositoryPath, { withFileTypes: true });
        const potentialTemplates = [];
        for (const entry of entries) {
            if (entry.isDirectory() && !entry.name.startsWith('.')) {
                const templatePath = path.join(repositoryPath, entry.name);
                const languages = await getLanguageDirectories(templatePath);
                if (languages.length > 0) {
                    potentialTemplates.push(entry.name);
                }
            }
        }
        return potentialTemplates;
    }
    catch (error) {
        return [];
    }
}
/**
 * Get valid CDK language directories from a template path
 * @param templatePath - Path to the template directory
 * @returns Promise resolving to array of supported language names
 */
async function getLanguageDirectories(templatePath) {
    const cdkSupportedLanguages = ['typescript', 'javascript', 'python', 'java', 'csharp', 'fsharp', 'go'];
    const languageExtensions = {
        typescript: ['.ts', '.js'],
        javascript: ['.js'],
        python: ['.py'],
        java: ['.java'],
        csharp: ['.cs'],
        fsharp: ['.fs'],
        go: ['.go'],
    };
    try {
        const entries = await fs.readdir(templatePath, { withFileTypes: true });
        const languageValidationPromises = entries
            .filter(directoryEntry => directoryEntry.isDirectory() && cdkSupportedLanguages.includes(directoryEntry.name))
            .map(async (directoryEntry) => {
            const languageDirectoryPath = path.join(templatePath, directoryEntry.name);
            try {
                const hasValidLanguageFiles = await hasLanguageFiles(languageDirectoryPath, languageExtensions[directoryEntry.name]);
                return hasValidLanguageFiles ? directoryEntry.name : null;
            }
            catch (error) {
                throw new toolkit_lib_1.ToolkitError(`Cannot read language directory '${directoryEntry.name}': ${error.message}`);
            }
        });
        /* eslint-disable-next-line @cdklabs/promiseall-no-unbounded-parallelism */ // Limited to supported CDK languages (7 max)
        const validationResults = await Promise.all(languageValidationPromises);
        return validationResults.filter((languageName) => languageName !== null);
    }
    catch (error) {
        throw new toolkit_lib_1.ToolkitError(`Cannot read template directory '${templatePath}': ${error.message}`);
    }
}
/**
 * Iteratively check if a directory contains files with the specified extensions
 * @param directoryPath - Path to search for language files
 * @param extensions - Array of file extensions to look for
 * @returns Promise resolving to true if language files are found
 */
async function hasLanguageFiles(directoryPath, extensions) {
    const dirsToCheck = [directoryPath];
    while (dirsToCheck.length > 0) {
        const currentDir = dirsToCheck.pop();
        try {
            const entries = await fs.readdir(currentDir, { withFileTypes: true });
            for (const entry of entries) {
                if (entry.isFile() && extensions.some(ext => entry.name.endsWith(ext))) {
                    return true;
                }
                else if (entry.isDirectory()) {
                    dirsToCheck.push(path.join(currentDir, entry.name));
                }
            }
        }
        catch (error) {
            throw error;
        }
    }
    return false;
}
/**
 * Returns the name of the Python executable for this OS
 * @returns The Python executable name for the current platform
 */
function pythonExecutable() {
    let python = 'python3';
    if (process.platform === 'win32') {
        python = 'python';
    }
    return python;
}
const INFO_DOT_JSON = 'info.json';
var TemplateType;
(function (TemplateType) {
    TemplateType["BUILT_IN"] = "builtin";
    TemplateType["CUSTOM"] = "custom";
})(TemplateType || (TemplateType = {}));
class InitTemplate {
    static async fromName(templatesDir, name) {
        const basePath = path.join(templatesDir, name);
        const languages = await listDirectory(basePath);
        const initInfo = await fs.readJson(path.join(basePath, INFO_DOT_JSON));
        return new InitTemplate(basePath, name, languages, initInfo, TemplateType.BUILT_IN);
    }
    static async fromPath(templatePath) {
        const basePath = path.resolve(templatePath);
        if (!await fs.pathExists(basePath)) {
            throw new toolkit_lib_1.ToolkitError(`Template path does not exist: ${basePath}`);
        }
        const languages = await getLanguageDirectories(basePath);
        const name = path.basename(basePath);
        return new InitTemplate(basePath, name, languages, null, TemplateType.CUSTOM);
    }
    constructor(basePath, name, languages, initInfo, templateType) {
        this.basePath = basePath;
        this.name = name;
        this.languages = languages;
        this.aliases = new Set();
        this.templateType = templateType;
        // Only built-in templates have descriptions and aliases from info.json
        if (templateType === TemplateType.BUILT_IN && initInfo) {
            this.description = initInfo.description;
            for (const alias of initInfo.aliases || []) {
                this.aliases.add(alias);
            }
        }
    }
    /**
     * @param name - the name that is being checked
     * @returns ``true`` if ``name`` is the name of this template or an alias of it.
     */
    hasName(name) {
        return name === this.name || this.aliases.has(name);
    }
    /**
     * Creates a new instance of this ``InitTemplate`` for a given language to a specified folder.
     *
     * @param language - the language to instantiate this template with
     * @param targetDirectory - the directory where the template is to be instantiated into
     * @param stackName - the name of the stack to create
     * @default undefined
     * @param libVersion - the version of the CDK library to use
     * @default undefined
     */
    async install(ioHelper, language, targetDirectory, stackName, libVersion) {
        if (this.languages.indexOf(language) === -1) {
            await ioHelper.defaults.error(`The ${chalk.blue(language)} language is not supported for ${chalk.green(this.name)} ` +
                `(it supports: ${this.languages.map((l) => chalk.blue(l)).join(', ')})`);
            throw new toolkit_lib_1.ToolkitError(`Unsupported language: ${language}`);
        }
        const projectInfo = {
            name: decamelize(path.basename(path.resolve(targetDirectory))),
            stackName,
            versions: await loadInitVersions(),
        };
        if (libVersion) {
            projectInfo.versions['aws-cdk-lib'] = libVersion;
        }
        const sourceDirectory = path.join(this.basePath, language);
        if (this.templateType === TemplateType.CUSTOM) {
            // For custom templates, copy files without processing placeholders
            await this.installFilesWithoutProcessing(sourceDirectory, targetDirectory);
        }
        else {
            // For built-in templates, process placeholders as usual
            await this.installFiles(sourceDirectory, targetDirectory, language, projectInfo);
            await this.applyFutureFlags(targetDirectory);
            await (0, init_hooks_1.invokeBuiltinHooks)(ioHelper, { targetDirectory, language, templateName: this.name }, {
                substitutePlaceholdersIn: async (...fileNames) => {
                    const fileProcessingPromises = fileNames.map(async (fileName) => {
                        const fullPath = path.join(targetDirectory, fileName);
                        const template = await fs.readFile(fullPath, { encoding: 'utf-8' });
                        await fs.writeFile(fullPath, expandPlaceholders(template, language, projectInfo));
                    });
                    /* eslint-disable-next-line @cdklabs/promiseall-no-unbounded-parallelism */ // Processing a small, known set of template files
                    await Promise.all(fileProcessingPromises);
                },
                placeholder: (ph) => expandPlaceholders(`%${ph}%`, language, projectInfo),
            });
        }
    }
    async installFiles(sourceDirectory, targetDirectory, language, project) {
        for (const file of await fs.readdir(sourceDirectory)) {
            const fromFile = path.join(sourceDirectory, file);
            const toFile = path.join(targetDirectory, expandPlaceholders(file, language, project));
            if ((await fs.stat(fromFile)).isDirectory()) {
                await fs.mkdir(toFile);
                await this.installFiles(fromFile, toFile, language, project);
                continue;
            }
            else if (file.match(/^.*\.template\.[^.]+$/)) {
                await this.installProcessed(fromFile, toFile.replace(/\.template(\.[^.]+)$/, '$1'), language, project);
                continue;
            }
            else if (file.match(/^.*\.hook\.(d.)?[^.]+$/)) {
                // Ignore
                continue;
            }
            else {
                await fs.copy(fromFile, toFile);
            }
        }
    }
    async installProcessed(templatePath, toFile, language, project) {
        const template = await fs.readFile(templatePath, { encoding: 'utf-8' });
        await fs.writeFile(toFile, expandPlaceholders(template, language, project));
    }
    /**
     * Copy template files without processing placeholders (for custom templates)
     */
    async installFilesWithoutProcessing(sourceDirectory, targetDirectory) {
        await fs.copy(sourceDirectory, targetDirectory, {
            filter: (src) => {
                const filename = path.basename(src);
                return !filename.match(/^.*\.hook\.(d.)?[^.]+$/);
            },
        });
    }
    /**
     * Adds context variables to `cdk.json` in the generated project directory to
     * enable future behavior for new projects.
     */
    async applyFutureFlags(projectDir) {
        const cdkJson = path.join(projectDir, 'cdk.json');
        if (!(await fs.pathExists(cdkJson))) {
            return;
        }
        const config = await fs.readJson(cdkJson);
        config.context = {
            ...config.context,
            ...await currentlyRecommendedAwsCdkLibFlags(),
        };
        await fs.writeJson(cdkJson, config, { spaces: 2 });
    }
    async addMigrateContext(projectDir) {
        const cdkJson = path.join(projectDir, 'cdk.json');
        if (!(await fs.pathExists(cdkJson))) {
            return;
        }
        const config = await fs.readJson(cdkJson);
        config.context = {
            ...config.context,
            'cdk-migrate': true,
        };
        await fs.writeJson(cdkJson, config, { spaces: 2 });
    }
}
exports.InitTemplate = InitTemplate;
function expandPlaceholders(template, language, project) {
    const cdkVersion = project.versions['aws-cdk-lib'];
    const cdkCliVersion = project.versions['aws-cdk'];
    let constructsVersion = project.versions.constructs;
    switch (language) {
        case 'java':
        case 'csharp':
        case 'fsharp':
            constructsVersion = (0, util_1.rangeFromSemver)(constructsVersion, 'bracket');
            break;
        case 'python':
            constructsVersion = (0, util_1.rangeFromSemver)(constructsVersion, 'pep');
            break;
    }
    return template
        .replace(/%name%/g, project.name)
        .replace(/%stackname%/, project.stackName ?? '%name.PascalCased%Stack')
        .replace(/%PascalNameSpace%/, project.stackName ? camelCase(project.stackName + 'Stack', { pascalCase: true }) : '%name.PascalCased%')
        .replace(/%PascalStackProps%/, project.stackName ? camelCase(project.stackName, { pascalCase: true }) + 'StackProps' : 'StackProps')
        .replace(/%name\.camelCased%/g, camelCase(project.name))
        .replace(/%name\.PascalCased%/g, camelCase(project.name, { pascalCase: true }))
        .replace(/%cdk-version%/g, cdkVersion)
        .replace(/%cdk-cli-version%/g, cdkCliVersion)
        .replace(/%constructs-version%/g, constructsVersion)
        .replace(/%cdk-home%/g, (0, util_1.cdkHomeDir)())
        .replace(/%name\.PythonModule%/g, project.name.replace(/-/g, '_'))
        .replace(/%python-executable%/g, pythonExecutable())
        .replace(/%name\.StackName%/g, project.name.replace(/[^A-Za-z0-9-]/g, '-'));
}
async function availableInitTemplates() {
    try {
        const templatesDir = path.join((0, root_dir_1.cliRootDir)(), 'lib', 'init-templates');
        const templateNames = await listDirectory(templatesDir);
        const templatePromises = templateNames.map(templateName => InitTemplate.fromName(templatesDir, templateName));
        /* eslint-disable-next-line @cdklabs/promiseall-no-unbounded-parallelism */ // Built-in templates are limited in number
        return await Promise.all(templatePromises);
    }
    catch (error) {
        // Return empty array if templates directory doesn't exist or can't be read
        // This allows the CLI to gracefully handle missing built-in templates
        if (error.code === 'ENOENT' || error.code === 'EACCES') {
            return [];
        }
        throw error;
    }
}
async function availableInitLanguages() {
    const templates = await availableInitTemplates();
    const result = new Set();
    for (const template of templates) {
        for (const language of template.languages) {
            const alias = (0, language_1.getLanguageAlias)(language);
            result.add(language);
            alias && result.add(alias);
        }
    }
    return [...result];
}
/**
 * @param dirPath - is the directory to be listed.
 * @returns the list of file or directory names contained in ``dirPath``, excluding any dot-file, and sorted.
 */
async function listDirectory(dirPath) {
    return ((await fs.readdir(dirPath))
        .filter((p) => !p.startsWith('.'))
        .filter((p) => !(p === 'LICENSE'))
        // if, for some reason, the temp folder for the hook doesn't get deleted we don't want to display it in this list
        .filter((p) => !(p === INFO_DOT_JSON))
        .sort());
}
/**
 * Print available templates to the user
 * @param ioHelper - IO helper for user interaction
 * @param language - Programming language filter
 * @default undefined
 */
async function printAvailableTemplates(ioHelper, language) {
    await ioHelper.defaults.info('Available templates:');
    for (const template of await availableInitTemplates()) {
        if (language && template.languages.indexOf(language) === -1) {
            continue;
        }
        await ioHelper.defaults.info(`* ${chalk.green(template.name)}: ${template.description}`);
        const languageArg = language
            ? chalk.bold(language)
            : template.languages.length > 1
                ? `[${template.languages.map((t) => chalk.bold(t)).join('|')}]`
                : chalk.bold(template.languages[0]);
        await ioHelper.defaults.info(`   └─ ${chalk.blue(`cdk init ${chalk.bold(template.name)} --language=${languageArg}`)}`);
    }
}
async function initializeProject(ioHelper, template, language, canUseNetwork, generateOnly, workDir, stackName, migrate, cdkVersion) {
    // Step 1: Ensure target directory is empty
    await assertIsEmptyDirectory(workDir);
    // Step 2: Copy template files
    await ioHelper.defaults.info(`Applying project template ${chalk.green(template.name)} for ${chalk.blue(language)}`);
    await template.install(ioHelper, language, workDir, stackName, cdkVersion);
    if (migrate) {
        await template.addMigrateContext(workDir);
    }
    if (await fs.pathExists(`${workDir}/README.md`)) {
        const readme = await fs.readFile(`${workDir}/README.md`, { encoding: 'utf-8' });
        await ioHelper.defaults.info(chalk.green(readme));
    }
    if (!generateOnly) {
        // Step 3: Initialize Git repository and create initial commit
        await initializeGitRepository(ioHelper, workDir);
        // Step 4: Post-install steps
        await postInstall(ioHelper, language, canUseNetwork, workDir);
    }
    await ioHelper.defaults.info('✅ All done!');
}
async function assertIsEmptyDirectory(workDir) {
    try {
        const files = await fs.readdir(workDir);
        if (files.filter((f) => !f.startsWith('.')).length !== 0) {
            throw new toolkit_lib_1.ToolkitError('`cdk init` cannot be run in a non-empty directory!');
        }
    }
    catch (e) {
        if (e.code === 'ENOENT') {
            throw new toolkit_lib_1.ToolkitError(`Directory does not exist: ${workDir}. Please create the directory first.`);
        }
        else {
            throw e;
        }
    }
}
async function initializeGitRepository(ioHelper, workDir) {
    if (await isInGitRepository(workDir)) {
        return;
    }
    await ioHelper.defaults.info('Initializing a new git repository...');
    try {
        await execute(ioHelper, 'git', ['init'], { cwd: workDir });
        await execute(ioHelper, 'git', ['add', '.'], { cwd: workDir });
        await execute(ioHelper, 'git', ['commit', '--message="Initial commit"', '--no-gpg-sign'], { cwd: workDir });
    }
    catch {
        await ioHelper.defaults.warn('Unable to initialize git repository for your project.');
    }
}
async function postInstall(ioHelper, language, canUseNetwork, workDir) {
    switch (language) {
        case 'javascript':
            return postInstallJavascript(ioHelper, canUseNetwork, workDir);
        case 'typescript':
            return postInstallTypescript(ioHelper, canUseNetwork, workDir);
        case 'java':
            return postInstallJava(ioHelper, canUseNetwork, workDir);
        case 'python':
            return postInstallPython(ioHelper, workDir);
        case 'go':
            return postInstallGo(ioHelper, canUseNetwork, workDir);
        case 'csharp':
            return postInstallCSharp(ioHelper, canUseNetwork, workDir);
        case 'fsharp':
            return postInstallFSharp(ioHelper, canUseNetwork, workDir);
    }
}
async function postInstallJavascript(ioHelper, canUseNetwork, cwd) {
    return postInstallTypescript(ioHelper, canUseNetwork, cwd);
}
async function postInstallTypescript(ioHelper, canUseNetwork, cwd) {
    const command = 'npm';
    if (!canUseNetwork) {
        await ioHelper.defaults.warn(`Please run '${command} install'!`);
        return;
    }
    await ioHelper.defaults.info(`Executing ${chalk.green(`${command} install`)}...`);
    try {
        await execute(ioHelper, command, ['install'], { cwd });
    }
    catch (e) {
        await ioHelper.defaults.warn(`${command} install failed: ` + (0, util_1.formatErrorMessage)(e));
    }
}
async function postInstallJava(ioHelper, canUseNetwork, cwd) {
    // Check if this is a Gradle or Maven project
    const hasGradleBuild = await fs.pathExists(path.join(cwd, 'build.gradle'));
    const hasMavenPom = await fs.pathExists(path.join(cwd, 'pom.xml'));
    if (hasGradleBuild) {
        // Gradle project
        const gradleWarning = "Please run './gradlew build'!";
        if (!canUseNetwork) {
            await ioHelper.defaults.warn(gradleWarning);
            return;
        }
        await ioHelper.defaults.info("Executing './gradlew build'");
        try {
            await execute(ioHelper, './gradlew', ['build'], { cwd });
        }
        catch {
            await ioHelper.defaults.warn('Unable to build Gradle project');
            await ioHelper.defaults.warn(gradleWarning);
        }
    }
    else if (hasMavenPom) {
        // Maven project
        const mvnPackageWarning = "Please run 'mvn package'!";
        if (!canUseNetwork) {
            await ioHelper.defaults.warn(mvnPackageWarning);
            return;
        }
        await ioHelper.defaults.info("Executing 'mvn package'");
        try {
            await execute(ioHelper, 'mvn', ['package'], { cwd });
        }
        catch {
            await ioHelper.defaults.warn('Unable to package compiled code as JAR');
            await ioHelper.defaults.warn(mvnPackageWarning);
        }
    }
    else {
        // No recognized build file
        await ioHelper.defaults.warn('No build.gradle or pom.xml found. Please set up your build system manually.');
    }
}
async function postInstallPython(ioHelper, cwd) {
    const python = pythonExecutable();
    // Check if requirements.txt exists
    const hasRequirements = await fs.pathExists(path.join(cwd, 'requirements.txt'));
    if (hasRequirements) {
        await ioHelper.defaults.info(`Executing ${chalk.green('Creating virtualenv...')}`);
        try {
            await execute(ioHelper, python, ['-m', 'venv', '.venv'], { cwd });
            await ioHelper.defaults.info(`Executing ${chalk.green('Installing dependencies...')}`);
            // Install dependencies in the virtual environment
            const pipPath = process.platform === 'win32' ? '.venv\\Scripts\\pip' : '.venv/bin/pip';
            await execute(ioHelper, pipPath, ['install', '-r', 'requirements.txt'], { cwd });
        }
        catch {
            await ioHelper.defaults.warn('Unable to create virtualenv or install dependencies automatically');
            await ioHelper.defaults.warn(`Please run '${python} -m venv .venv && .venv/bin/pip install -r requirements.txt'!`);
        }
    }
    else {
        await ioHelper.defaults.warn('No requirements.txt found. Please set up your Python environment manually.');
    }
}
async function postInstallGo(ioHelper, canUseNetwork, cwd) {
    if (!canUseNetwork) {
        await ioHelper.defaults.warn('Please run \'go mod tidy\'!');
        return;
    }
    await ioHelper.defaults.info(`Executing ${chalk.green('go mod tidy')}...`);
    try {
        await execute(ioHelper, 'go', ['mod', 'tidy'], { cwd });
    }
    catch (e) {
        await ioHelper.defaults.warn('\'go mod tidy\' failed: ' + (0, util_1.formatErrorMessage)(e));
    }
}
async function postInstallCSharp(ioHelper, canUseNetwork, cwd) {
    const dotnetWarning = "Please run 'dotnet restore && dotnet build'!";
    if (!canUseNetwork) {
        await ioHelper.defaults.warn(dotnetWarning);
        return;
    }
    await ioHelper.defaults.info(`Executing ${chalk.green('dotnet restore')}...`);
    try {
        await execute(ioHelper, 'dotnet', ['restore'], { cwd });
        await ioHelper.defaults.info(`Executing ${chalk.green('dotnet build')}...`);
        await execute(ioHelper, 'dotnet', ['build'], { cwd });
    }
    catch (e) {
        await ioHelper.defaults.warn('Unable to restore/build .NET project: ' + (0, util_1.formatErrorMessage)(e));
        await ioHelper.defaults.warn(dotnetWarning);
    }
}
async function postInstallFSharp(ioHelper, canUseNetwork, cwd) {
    // F# uses the same build system as C#
    return postInstallCSharp(ioHelper, canUseNetwork, cwd);
}
/**
 * @param dir - a directory to be checked
 * @returns true if ``dir`` is within a git repository.
 */
async function isInGitRepository(dir) {
    while (true) {
        if (await fs.pathExists(path.join(dir, '.git'))) {
            return true;
        }
        if (isRoot(dir)) {
            return false;
        }
        dir = path.dirname(dir);
    }
}
/**
 * @param dir - a directory to be checked.
 * @returns true if ``dir`` is the root of a filesystem.
 */
function isRoot(dir) {
    return path.dirname(dir) === dir;
}
/**
 * Executes `command`. STDERR is emitted in real-time.
 *
 * If command exits with non-zero exit code, an exception is thrown and includes
 * the contents of STDOUT.
 *
 * @returns STDOUT (if successful).
 */
async function execute(ioHelper, cmd, args, { cwd }) {
    const child = childProcess.spawn(cmd, args, {
        cwd,
        shell: true,
        stdio: ['ignore', 'pipe', 'inherit'],
    });
    let stdout = '';
    child.stdout.on('data', (chunk) => (stdout += chunk.toString()));
    return new Promise((ok, fail) => {
        child.once('error', (err) => fail(err));
        child.once('exit', (status) => {
            if (status === 0) {
                return ok(stdout);
            }
            else {
                return fail(new toolkit_lib_1.ToolkitError(`${cmd} exited with status ${status}`));
            }
        });
    }).catch(async (err) => {
        await ioHelper.defaults.error(stdout);
        throw err;
    });
}
/**
 * Return the 'aws-cdk-lib' version we will init
 *
 * This has been built into the CLI at build time.
 */
async function loadInitVersions() {
    const initVersionFile = path.join((0, root_dir_1.cliRootDir)(), 'lib', 'init-templates', '.init-version.json');
    const contents = JSON.parse(await fs.readFile(initVersionFile, { encoding: 'utf-8' }));
    const ret = {
        'aws-cdk-lib': contents['aws-cdk-lib'],
        'constructs': contents.constructs,
        'aws-cdk': (0, version_1.versionNumber)(),
    };
    for (const [key, value] of Object.entries(ret)) {
        if (!value) {
            throw new toolkit_lib_1.ToolkitError(`Missing init version from ${initVersionFile}: ${key}`);
        }
    }
    return ret;
}
/**
 * Return the currently recommended flags for `aws-cdk-lib`.
 *
 * These have been built into the CLI at build time.
 */
async function currentlyRecommendedAwsCdkLibFlags() {
    const recommendedFlagsFile = path.join((0, root_dir_1.cliRootDir)(), 'lib', 'init-templates', '.recommended-feature-flags.json');
    return JSON.parse(await fs.readFile(recommendedFlagsFile, { encoding: 'utf-8' }));
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5pdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImluaXQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBaUZBLDBCQW1DQztBQW1ZRCxnREFtQ0M7QUFVRCx3REFpQkM7QUFFRCx3REFXQztBQXVCRCwwREFjQztBQTBTRCxnRkFHQztBQXA1QkQsOENBQThDO0FBQzlDLDZCQUE2QjtBQUM3QixzREFBb0Q7QUFDcEQsK0JBQStCO0FBQy9CLCtCQUErQjtBQUMvQiw2Q0FBa0Q7QUFFbEQsaURBQWdEO0FBQ2hELCtDQUFrRDtBQUNsRCxxQ0FBNkU7QUFDN0UsMENBQStDO0FBRS9DLHVEQUF1RCxDQUFDLG9DQUFvQztBQUM1RixpRUFBaUU7QUFDakUsTUFBTSxTQUFTLEdBQUcsT0FBTyxDQUFDLFdBQVcsQ0FBQyxDQUFDO0FBQ3ZDLGlFQUFpRTtBQUNqRSxNQUFNLFVBQVUsR0FBRyxPQUFPLENBQUMsWUFBWSxDQUFDLENBQUM7QUE4RHpDOztHQUVHO0FBQ0ksS0FBSyxVQUFVLE9BQU8sQ0FBQyxPQUF1QjtJQUNuRCxNQUFNLFFBQVEsR0FBRyxPQUFPLENBQUMsUUFBUSxDQUFDO0lBQ2xDLE1BQU0sYUFBYSxHQUFHLE9BQU8sQ0FBQyxhQUFhLElBQUksSUFBSSxDQUFDO0lBQ3BELE1BQU0sWUFBWSxHQUFHLE9BQU8sQ0FBQyxZQUFZLElBQUksS0FBSyxDQUFDO0lBQ25ELE1BQU0sT0FBTyxHQUFHLE9BQU8sQ0FBQyxPQUFPLElBQUksT0FBTyxDQUFDLEdBQUcsRUFBRSxDQUFDO0lBRWpELG1GQUFtRjtJQUNuRixJQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxFQUFFLENBQUM7UUFDNUQsTUFBTSx1QkFBdUIsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUN4QyxPQUFPO0lBQ1QsQ0FBQztJQUVELHdCQUF3QjtJQUN4QixJQUFJLFFBQXNCLENBQUM7SUFDM0IsSUFB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LDZCQUE2QixlQUFlLEtBQUssR0FBRyxFQUFFLENBQUMsQ0FBQztRQUNqRixDQUFDO0lBQ0gsQ0FBQztJQUVELE9BQU8sR0FBRyxDQUFDO0FBQ2IsQ0FBQztBQUVEOzs7O0dBSUc7QUFDSSxLQUFLLFVBQVUsa0NBQWtDO0lBQ3RELE1BQU0sb0JBQW9CLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFBLHFCQUFVLEdBQUUsRUFBRSxLQUFLLEVBQUUsZ0JBQWdCLEVBQUUsaUNBQWlDLENBQUMsQ0FBQztJQUNqSCxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUMsUUFBUSxDQUFDLG9CQUFvQixFQUFFLEVBQUUsUUFBUSxFQUFFLE9BQU8sRUFBRSxDQUFDLENBQUMsQ0FBQztBQUNwRixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgY2hpbGRQcm9jZXNzIGZyb20gJ2NoaWxkX3Byb2Nlc3MnO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB7IFRvb2xraXRFcnJvciB9IGZyb20gJ0Bhd3MtY2RrL3Rvb2xraXQtbGliJztcbmltcG9ydCAqIGFzIGNoYWxrIGZyb20gJ2NoYWxrJztcbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzLWV4dHJhJztcbmltcG9ydCB7IGludm9rZUJ1aWx0aW5Ib29rcyB9IGZyb20gJy4vaW5pdC1ob29rcyc7XG5pbXBvcnQgdHlwZSB7IElvSGVscGVyIH0gZnJvbSAnLi4vLi4vYXBpLXByaXZhdGUnO1xuaW1wb3J0IHsgY2xpUm9vdERpciB9IGZyb20gJy4uLy4uL2NsaS9yb290LWRpcic7XG5pbXBvcnQgeyB2ZXJzaW9uTnVtYmVyIH0gZnJvbSAnLi4vLi4vY2xpL3ZlcnNpb24nO1xuaW1wb3J0IHsgY2RrSG9tZURpciwgZm9ybWF0RXJyb3JNZXNzYWdlLCByYW5nZUZyb21TZW12ZXIgfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7IGdldExhbmd1YWdlQWxpYXMgfSBmcm9tICcuLi9sYW5ndWFnZSc7XG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby12YXItcmVxdWlyZXMgKi8gLy8gUGFja2FnZXMgZG9uJ3QgaGF2ZSBAdHlwZXMgbW9kdWxlXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0c1xuY29uc3QgY2FtZWxDYXNlID0gcmVxdWlyZSgnY2FtZWxjYXNlJyk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0c1xuY29uc3QgZGVjYW1lbGl6ZSA9IHJlcXVpcmUoJ2RlY2FtZWxpemUnKTtcblxuZXhwb3J0IGludGVyZmFjZSBDbGlJbml0T3B0aW9ucyB7XG4gIC8qKlxuICAgKiBUZW1wbGF0ZSBuYW1lIHRvIGluaXRpYWxpemVcbiAgICogQGRlZmF1bHQgdW5kZWZpbmVkXG4gICAqL1xuICByZWFkb25seSB0eXBlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBQcm9ncmFtbWluZyBsYW5ndWFnZSBmb3IgdGhlIHByb2plY3RcbiAgICogQGRlZmF1bHQgLSBPcHRpb25hbC9hdXRvLWRldGVjdGVkIGlmIHRlbXBsYXRlIHN1cHBvcnRzIG9ubHkgb25lIGxhbmd1YWdlLCBvdGhlcndpc2UgcmVxdWlyZWRcbiAgICovXG4gIHJlYWRvbmx5IGxhbmd1YWdlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICByZWFkb25seSBjYW5Vc2VOZXR3b3JrPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHJlYWRvbmx5IGdlbmVyYXRlT25seT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEBkZWZhdWx0IHByb2Nlc3MuY3dkKClcbiAgICovXG4gIHJlYWRvbmx5IHdvcmtEaXI/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuICAgKi9cbiAgcmVhZG9ubHkgc3RhY2tOYW1lPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcbiAgICovXG4gIHJlYWRvbmx5IG1pZ3JhdGU/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBPdmVycmlkZSB0aGUgYnVpbHQtaW4gQ0RLIHZlcnNpb25cbiAgICogQGRlZmF1bHQgdW5kZWZpbmVkXG4gICAqL1xuICByZWFkb25seSBsaWJWZXJzaW9uPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBQYXRoIHRvIGEgbG9jYWwgY3VzdG9tIHRlbXBsYXRlIGRpcmVjdG9yeVxuICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcbiAgICovXG4gIHJlYWRvbmx5IGZyb21QYXRoPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBQYXRoIHRvIGEgc3BlY2lmaWMgdGVtcGxhdGUgd2l0aGluIGEgbXVsdGktdGVtcGxhdGUgcmVwb3NpdG9yeS5cbiAgICogVGhpcyBwYXJhbWV0ZXIgcmVxdWlyZXMgLS1mcm9tLXBhdGggdG8gYmUgc3BlY2lmaWVkLlxuICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcbiAgICovXG4gIHJlYWRvbmx5IHRlbXBsYXRlUGF0aD86IHN0cmluZztcblxuICByZWFkb25seSBpb0hlbHBlcjogSW9IZWxwZXI7XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIENESyBwYWNrYWdlIGluIHRoZSBjdXJyZW50IGRpcmVjdG9yeVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2xpSW5pdChvcHRpb25zOiBDbGlJbml0T3B0aW9ucykge1xuICBjb25zdCBpb0hlbHBlciA9IG9wdGlvbnMuaW9IZWxwZXI7XG4gIGNvbnN0IGNhblVzZU5ldHdvcmsgPSBvcHRpb25zLmNhblVzZU5ldHdvcmsgPz8gdHJ1ZTtcbiAgY29uc3QgZ2VuZXJhdGVPbmx5ID0gb3B0aW9ucy5nZW5lcmF0ZU9ubHkgPz8gZmFsc2U7XG4gIGNvbnN0IHdvcmtEaXIgPSBvcHRpb25zLndvcmtEaXIgPz8gcHJvY2Vzcy5jd2QoKTtcblxuICAvLyBTaG93IGF2YWlsYWJsZSB0ZW1wbGF0ZXMgaWYgbm8gdHlwZSBhbmQgbm8gbGFuZ3VhZ2UgcHJvdmlkZWQgKG1haW4gYnJhbmNoIGxvZ2ljKVxuICBpZiAoIW9wdGlvbnMuZnJvbVBhdGggJiYgIW9wdGlvbnMudHlwZSAmJiAhb3B0aW9ucy5sYW5ndWFnZSkge1xuICAgIGF3YWl0IHByaW50QXZhaWxhYmxlVGVtcGxhdGVzKGlvSGVscGVyKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBTdGVwIDE6IExvYWQgdGVtcGxhdGVcbiAgbGV0IHRlbXBsYXRlOiBJbml0VGVtcGxhdGU7XG4gIGlmIChvcHRpb25zLmZyb21QYXRoKSB7XG4gICAgdGVtcGxhdGUgPSBhd2FpdCBsb2FkTG9jYWxUZW1wbGF0ZShvcHRpb25zLmZyb21QYXRoLCBvcHRpb25zLnRlbXBsYXRlUGF0aCk7XG4gIH0gZWxzZSB7XG4gICAgdGVtcGxhdGUgPSBhd2FpdCBsb2FkQnVpbHRpblRlbXBsYXRlKGlvSGVscGVyLCBvcHRpb25zLnR5cGUsIG9wdGlvbnMubGFuZ3VhZ2UpO1xuICB9XG5cbiAgLy8gU3RlcCAyOiBSZXNvbHZlIGxhbmd1YWdlXG4gIGNvbnN0IGxhbmd1YWdlID0gYXdhaXQgcmVzb2x2ZUxhbmd1YWdlKGlvSGVscGVyLCB0ZW1wbGF0ZSwgb3B0aW9ucy5sYW5ndWFnZSwgb3B0aW9ucy50eXBlKTtcblxuICAvLyBTdGVwIDM6IEluaXRpYWxpemUgcHJvamVjdCBmb2xsb3dpbmcgc3RhbmRhcmQgcHJvY2Vzc1xuICBhd2FpdCBpbml0aWFsaXplUHJvamVjdChcbiAgICBpb0hlbHBlcixcbiAgICB0ZW1wbGF0ZSxcbiAgICBsYW5ndWFnZSxcbiAgICBjYW5Vc2VOZXR3b3JrLFxuICAgIGdlbmVyYXRlT25seSxcbiAgICB3b3JrRGlyLFxuICAgIG9wdGlvbnMuc3RhY2tOYW1lLFxuICAgIG9wdGlvbnMubWlncmF0ZSxcbiAgICBvcHRpb25zLmxpYlZlcnNpb24sXG4gICk7XG59XG5cbi8qKlxuICogTG9hZCBhIGxvY2FsIGN1c3RvbSB0ZW1wbGF0ZSBmcm9tIGZpbGUgc3lzdGVtIHBhdGhcbiAqIEBwYXJhbSBmcm9tUGF0aCAtIFBhdGggdG8gdGhlIGxvY2FsIHRlbXBsYXRlIGRpcmVjdG9yeSBvciBtdWx0aS10ZW1wbGF0ZSByZXBvc2l0b3J5XG4gKiBAcGFyYW0gdGVtcGxhdGVQYXRoIC0gT3B0aW9uYWwgcGF0aCB0byBhIHNwZWNpZmljIHRlbXBsYXRlIHdpdGhpbiBhIG11bHRpLXRlbXBsYXRlIHJlcG9zaXRvcnlcbiAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBsb2FkZWQgSW5pdFRlbXBsYXRlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGxvYWRMb2NhbFRlbXBsYXRlKGZyb21QYXRoOiBzdHJpbmcsIHRlbXBsYXRlUGF0aD86IHN0cmluZyk6IFByb21pc2U8SW5pdFRlbXBsYXRlPiB7XG4gIHRyeSB7XG4gICAgbGV0IGFjdHVhbFRlbXBsYXRlUGF0aCA9IGZyb21QYXRoO1xuXG4gICAgLy8gSWYgdGVtcGxhdGVQYXRoIGlzIHByb3ZpZGVkLCBpdCdzIGEgbXVsdGktdGVtcGxhdGUgcmVwb3NpdG9yeVxuICAgIGlmICh0ZW1wbGF0ZVBhdGgpIHtcbiAgICAgIGFjdHVhbFRlbXBsYXRlUGF0aCA9IHBhdGguam9pbihmcm9tUGF0aCwgdGVtcGxhdGVQYXRoKTtcblxuICAgICAgaWYgKCFhd2FpdCBmcy5wYXRoRXhpc3RzKGFjdHVhbFRlbXBsYXRlUGF0aCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcihgVGVtcGxhdGUgcGF0aCBkb2VzIG5vdCBleGlzdDogJHthY3R1YWxUZW1wbGF0ZVBhdGh9YCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgdGVtcGxhdGUgPSBhd2FpdCBJbml0VGVtcGxhdGUuZnJvbVBhdGgoYWN0dWFsVGVtcGxhdGVQYXRoKTtcblxuICAgIGlmICh0ZW1wbGF0ZS5sYW5ndWFnZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBDaGVjayBpZiB0aGlzIG1pZ2h0IGJlIGEgbXVsdGktdGVtcGxhdGUgcmVwb3NpdG9yeVxuICAgICAgaWYgKCF0ZW1wbGF0ZVBhdGgpIHtcbiAgICAgICAgY29uc3QgYXZhaWxhYmxlVGVtcGxhdGVzID0gYXdhaXQgZmluZFBvdGVudGlhbFRlbXBsYXRlcyhmcm9tUGF0aCk7XG4gICAgICAgIGlmIChhdmFpbGFibGVUZW1wbGF0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoXG4gICAgICAgICAgICAnVXNlIC0tdGVtcGxhdGUtcGF0aCB0byBzcGVjaWZ5IHdoaWNoIHRlbXBsYXRlIHRvIHVzZS4nLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoJ0N1c3RvbSB0ZW1wbGF0ZSBtdXN0IGNvbnRhaW4gYXQgbGVhc3Qgb25lIGxhbmd1YWdlIGRpcmVjdG9yeScpO1xuICAgIH1cblxuICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnN0IGRpc3BsYXlQYXRoID0gdGVtcGxhdGVQYXRoID8gYCR7ZnJvbVBhdGh9LyR7dGVtcGxhdGVQYXRofWAgOiBmcm9tUGF0aDtcbiAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKGBGYWlsZWQgdG8gbG9hZCB0ZW1wbGF0ZSBmcm9tIHBhdGg6ICR7ZGlzcGxheVBhdGh9LiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBMb2FkIGEgYnVpbHQtaW4gdGVtcGxhdGUgYnkgbmFtZVxuICovXG5hc3luYyBmdW5jdGlvbiBsb2FkQnVpbHRpblRlbXBsYXRlKGlvSGVscGVyOiBJb0hlbHBlciwgdHlwZT86IHN0cmluZywgbGFuZ3VhZ2U/OiBzdHJpbmcpOiBQcm9taXNlPEluaXRUZW1wbGF0ZT4ge1xuICBjb25zdCB0ZW1wbGF0ZVR5cGUgPSB0eXBlIHx8ICdkZWZhdWx0JzsgLy8gXCJkZWZhdWx0XCIgaXMgdGhlIGRlZmF1bHQgdHlwZSAoYW5kIG1hcHMgdG8gXCJhcHBcIilcblxuICBjb25zdCB0ZW1wbGF0ZSA9IChhd2FpdCBhdmFpbGFibGVJbml0VGVtcGxhdGVzKCkpLmZpbmQoKHQpID0+IHQuaGFzTmFtZSh0ZW1wbGF0ZVR5cGUpKTtcbiAgaWYgKCF0ZW1wbGF0ZSkge1xuICAgIGF3YWl0IHByaW50QXZhaWxhYmxlVGVtcGxhdGVzKGlvSGVscGVyLCBsYW5ndWFnZSk7XG4gICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcihgVW5rbm93biBpbml0IHRlbXBsYXRlOiAke3RlbXBsYXRlVHlwZX1gKTtcbiAgfVxuXG4gIHJldHVybiB0ZW1wbGF0ZTtcbn1cblxuLyoqXG4gKiBSZXNvbHZlIHRoZSBwcm9ncmFtbWluZyBsYW5ndWFnZSBmb3IgdGhlIHRlbXBsYXRlXG4gKiBAcGFyYW0gaW9IZWxwZXIgLSBJTyBoZWxwZXIgZm9yIHVzZXIgaW50ZXJhY3Rpb25cbiAqIEBwYXJhbSB0ZW1wbGF0ZSAtIFRoZSB0ZW1wbGF0ZSB0byByZXNvbHZlIGxhbmd1YWdlIGZvclxuICogQHBhcmFtIHJlcXVlc3RlZExhbmd1YWdlIC0gVXNlci1yZXF1ZXN0ZWQgbGFuZ3VhZ2UgKG9wdGlvbmFsKVxuICogQHBhcmFtIHR5cGUgLSBUaGUgdGVtcGxhdGUgdHlwZSBuYW1lIGZvciBtZXNzYWdlc1xuICogQGRlZmF1bHQgdW5kZWZpbmVkXG4gKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgc2VsZWN0ZWQgbGFuZ3VhZ2VcbiAqL1xuYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZUxhbmd1YWdlKGlvSGVscGVyOiBJb0hlbHBlciwgdGVtcGxhdGU6IEluaXRUZW1wbGF0ZSwgcmVxdWVzdGVkTGFuZ3VhZ2U/OiBzdHJpbmcsIHR5cGU/OiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICByZXR1cm4gKGFzeW5jICgpID0+IHtcbiAgICBpZiAocmVxdWVzdGVkTGFuZ3VhZ2UpIHtcbiAgICAgIHJldHVybiByZXF1ZXN0ZWRMYW5ndWFnZTtcbiAgICB9XG4gICAgaWYgKHRlbXBsYXRlLmxhbmd1YWdlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGNvbnN0IHRlbXBsYXRlTGFuZ3VhZ2UgPSB0ZW1wbGF0ZS5sYW5ndWFnZXNbMF07XG4gICAgICAvLyBPbmx5IHNob3cgYXV0by1kZXRlY3Rpb24gbWVzc2FnZSBmb3IgYnVpbHQtaW4gdGVtcGxhdGVzXG4gICAgICBpZiAodGVtcGxhdGUudGVtcGxhdGVUeXBlICE9PSBUZW1wbGF0ZVR5cGUuQ1VTVE9NKSB7XG4gICAgICAgIGF3YWl0IGlvSGVscGVyLmRlZmF1bHRzLndhcm4oXG4gICAgICAgICAgYE5vIC0tbGFuZ3VhZ2Ugd2FzIHByb3ZpZGVkLCBidXQgJyR7dHlwZSB8fCB0ZW1wbGF0ZS5uYW1lfScgc3VwcG9ydHMgb25seSAnJHt0ZW1wbGF0ZUxhbmd1YWdlfScsIHNvIGRlZmF1bHRpbmcgdG8gLS1sYW5ndWFnZT0ke3RlbXBsYXRlTGFuZ3VhZ2V9YCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0ZW1wbGF0ZUxhbmd1YWdlO1xuICAgIH1cbiAgICBhd2FpdCBpb0hlbHBlci5kZWZhdWx0cy5pbmZvKFxuICAgICAgYEF2YWlsYWJsZSBsYW5ndWFnZXMgZm9yICR7Y2hhbGsuZ3JlZW4odHlwZSB8fCB0ZW1wbGF0ZS5uYW1lKX06ICR7dGVtcGxhdGUubGFuZ3VhZ2VzLm1hcCgobCkgPT4gY2hhbGsuYmx1ZShsKSkuam9pbignLCAnKX1gLFxuICAgICk7XG4gICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcignTm8gbGFuZ3VhZ2Ugd2FzIHNlbGVjdGVkJyk7XG4gIH0pKCk7XG59XG5cbi8qKlxuICogRmluZCBwb3RlbnRpYWwgdGVtcGxhdGUgZGlyZWN0b3JpZXMgaW4gYSBtdWx0aS10ZW1wbGF0ZSByZXBvc2l0b3J5XG4gKiBAcGFyYW0gcmVwb3NpdG9yeVBhdGggLSBQYXRoIHRvIHRoZSByZXBvc2l0b3J5IHJvb3RcbiAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIGFycmF5IG9mIHBvdGVudGlhbCB0ZW1wbGF0ZSBkaXJlY3RvcnkgbmFtZXNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZmluZFBvdGVudGlhbFRlbXBsYXRlcyhyZXBvc2l0b3J5UGF0aDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICB0cnkge1xuICAgIGNvbnN0IGVudHJpZXMgPSBhd2FpdCBmcy5yZWFkZGlyKHJlcG9zaXRvcnlQYXRoLCB7IHdpdGhGaWxlVHlwZXM6IHRydWUgfSk7XG4gICAgY29uc3QgcG90ZW50aWFsVGVtcGxhdGVzOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XG4gICAgICBpZiAoZW50cnkuaXNEaXJlY3RvcnkoKSAmJiAhZW50cnkubmFtZS5zdGFydHNXaXRoKCcuJykpIHtcbiAgICAgICAgY29uc3QgdGVtcGxhdGVQYXRoID0gcGF0aC5qb2luKHJlcG9zaXRvcnlQYXRoLCBlbnRyeS5uYW1lKTtcbiAgICAgICAgY29uc3QgbGFuZ3VhZ2VzID0gYXdhaXQgZ2V0TGFuZ3VhZ2VEaXJlY3Rvcmllcyh0ZW1wbGF0ZVBhdGgpO1xuICAgICAgICBpZiAobGFuZ3VhZ2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBwb3RlbnRpYWxUZW1wbGF0ZXMucHVzaChlbnRyeS5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwb3RlbnRpYWxUZW1wbGF0ZXM7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgdmFsaWQgQ0RLIGxhbmd1YWdlIGRpcmVjdG9yaWVzIGZyb20gYSB0ZW1wbGF0ZSBwYXRoXG4gKiBAcGFyYW0gdGVtcGxhdGVQYXRoIC0gUGF0aCB0byB0aGUgdGVtcGxhdGUgZGlyZWN0b3J5XG4gKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBhcnJheSBvZiBzdXBwb3J0ZWQgbGFuZ3VhZ2UgbmFtZXNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0TGFuZ3VhZ2VEaXJlY3Rvcmllcyh0ZW1wbGF0ZVBhdGg6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgY29uc3QgY2RrU3VwcG9ydGVkTGFuZ3VhZ2VzID0gWyd0eXBlc2NyaXB0JywgJ2phdmFzY3JpcHQnLCAncHl0aG9uJywgJ2phdmEnLCAnY3NoYXJwJywgJ2ZzaGFycCcsICdnbyddO1xuICBjb25zdCBsYW5ndWFnZUV4dGVuc2lvbnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZ1tdPiA9IHtcbiAgICB0eXBlc2NyaXB0OiBbJy50cycsICcuanMnXSxcbiAgICBqYXZhc2NyaXB0OiBbJy5qcyddLFxuICAgIHB5dGhvbjogWycucHknXSxcbiAgICBqYXZhOiBbJy5qYXZhJ10sXG4gICAgY3NoYXJwOiBbJy5jcyddLFxuICAgIGZzaGFycDogWycuZnMnXSxcbiAgICBnbzogWycuZ28nXSxcbiAgfTtcblxuICB0cnkge1xuICAgIGNvbnN0IGVudHJpZXMgPSBhd2FpdCBmcy5yZWFkZGlyKHRlbXBsYXRlUGF0aCwgeyB3aXRoRmlsZVR5cGVzOiB0cnVlIH0pO1xuXG4gICAgY29uc3QgbGFuZ3VhZ2VWYWxpZGF0aW9uUHJvbWlzZXMgPSBlbnRyaWVzXG4gICAgICAuZmlsdGVyKGRpcmVjdG9yeUVudHJ5ID0+IGRpcmVjdG9yeUVudHJ5LmlzRGlyZWN0b3J5KCkgJiYgY2RrU3VwcG9ydGVkTGFuZ3VhZ2VzLmluY2x1ZGVzKGRpcmVjdG9yeUVudHJ5Lm5hbWUpKVxuICAgICAgLm1hcChhc3luYyAoZGlyZWN0b3J5RW50cnkpID0+IHtcbiAgICAgICAgY29uc3QgbGFuZ3VhZ2VEaXJlY3RvcnlQYXRoID0gcGF0aC5qb2luKHRlbXBsYXRlUGF0aCwgZGlyZWN0b3J5RW50cnkubmFtZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgaGFzVmFsaWRMYW5ndWFnZUZpbGVzID0gYXdhaXQgaGFzTGFuZ3VhZ2VGaWxlcyhsYW5ndWFnZURpcmVjdG9yeVBhdGgsIGxhbmd1YWdlRXh0ZW5zaW9uc1tkaXJlY3RvcnlFbnRyeS5uYW1lXSk7XG4gICAgICAgICAgcmV0dXJuIGhhc1ZhbGlkTGFuZ3VhZ2VGaWxlcyA/IGRpcmVjdG9yeUVudHJ5Lm5hbWUgOiBudWxsO1xuICAgICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcihgQ2Fubm90IHJlYWQgbGFuZ3VhZ2UgZGlyZWN0b3J5ICcke2RpcmVjdG9yeUVudHJ5Lm5hbWV9JzogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgIC8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAY2RrbGFicy9wcm9taXNlYWxsLW5vLXVuYm91bmRlZC1wYXJhbGxlbGlzbSAqLyAvLyBMaW1pdGVkIHRvIHN1cHBvcnRlZCBDREsgbGFuZ3VhZ2VzICg3IG1heClcbiAgICBjb25zdCB2YWxpZGF0aW9uUmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKGxhbmd1YWdlVmFsaWRhdGlvblByb21pc2VzKTtcbiAgICByZXR1cm4gdmFsaWRhdGlvblJlc3VsdHMuZmlsdGVyKChsYW5ndWFnZU5hbWUpOiBsYW5ndWFnZU5hbWUgaXMgc3RyaW5nID0+IGxhbmd1YWdlTmFtZSAhPT0gbnVsbCk7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKGBDYW5ub3QgcmVhZCB0ZW1wbGF0ZSBkaXJlY3RvcnkgJyR7dGVtcGxhdGVQYXRofSc6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgfVxufVxuXG4vKipcbiAqIEl0ZXJhdGl2ZWx5IGNoZWNrIGlmIGEgZGlyZWN0b3J5IGNvbnRhaW5zIGZpbGVzIHdpdGggdGhlIHNwZWNpZmllZCBleHRlbnNpb25zXG4gKiBAcGFyYW0gZGlyZWN0b3J5UGF0aCAtIFBhdGggdG8gc2VhcmNoIGZvciBsYW5ndWFnZSBmaWxlc1xuICogQHBhcmFtIGV4dGVuc2lvbnMgLSBBcnJheSBvZiBmaWxlIGV4dGVuc2lvbnMgdG8gbG9vayBmb3JcbiAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHRydWUgaWYgbGFuZ3VhZ2UgZmlsZXMgYXJlIGZvdW5kXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGhhc0xhbmd1YWdlRmlsZXMoZGlyZWN0b3J5UGF0aDogc3RyaW5nLCBleHRlbnNpb25zOiBzdHJpbmdbXSk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICBjb25zdCBkaXJzVG9DaGVjayA9IFtkaXJlY3RvcnlQYXRoXTtcblxuICB3aGlsZSAoZGlyc1RvQ2hlY2subGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IGN1cnJlbnREaXIgPSBkaXJzVG9DaGVjay5wb3AoKSE7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgZW50cmllcyA9IGF3YWl0IGZzLnJlYWRkaXIoY3VycmVudERpciwgeyB3aXRoRmlsZVR5cGVzOiB0cnVlIH0pO1xuXG4gICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgICAgICAgaWYgKGVudHJ5LmlzRmlsZSgpICYmIGV4dGVuc2lvbnMuc29tZShleHQgPT4gZW50cnkubmFtZS5lbmRzV2l0aChleHQpKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGVudHJ5LmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgICBkaXJzVG9DaGVjay5wdXNoKHBhdGguam9pbihjdXJyZW50RGlyLCBlbnRyeS5uYW1lKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbmFtZSBvZiB0aGUgUHl0aG9uIGV4ZWN1dGFibGUgZm9yIHRoaXMgT1NcbiAqIEByZXR1cm5zIFRoZSBQeXRob24gZXhlY3V0YWJsZSBuYW1lIGZvciB0aGUgY3VycmVudCBwbGF0Zm9ybVxuICovXG5mdW5jdGlvbiBweXRob25FeGVjdXRhYmxlKCkge1xuICBsZXQgcHl0aG9uID0gJ3B5dGhvbjMnO1xuICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJykge1xuICAgIHB5dGhvbiA9ICdweXRob24nO1xuICB9XG4gIHJldHVybiBweXRob247XG59XG5jb25zdCBJTkZPX0RPVF9KU09OID0gJ2luZm8uanNvbic7XG5cbmludGVyZmFjZSBUZW1wbGF0ZUluaXRJbmZvIHtcbiAgcmVhZG9ubHkgZGVzY3JpcHRpb246IHN0cmluZztcbiAgcmVhZG9ubHkgYWxpYXNlcz86IHN0cmluZ1tdO1xufVxuXG5lbnVtIFRlbXBsYXRlVHlwZSB7XG4gIEJVSUxUX0lOID0gJ2J1aWx0aW4nLFxuICBDVVNUT00gPSAnY3VzdG9tJyxcbn1cblxuZXhwb3J0IGNsYXNzIEluaXRUZW1wbGF0ZSB7XG4gIHB1YmxpYyBzdGF0aWMgYXN5bmMgZnJvbU5hbWUodGVtcGxhdGVzRGlyOiBzdHJpbmcsIG5hbWU6IHN0cmluZykge1xuICAgIGNvbnN0IGJhc2VQYXRoID0gcGF0aC5qb2luKHRlbXBsYXRlc0RpciwgbmFtZSk7XG4gICAgY29uc3QgbGFuZ3VhZ2VzID0gYXdhaXQgbGlzdERpcmVjdG9yeShiYXNlUGF0aCk7XG4gICAgY29uc3QgaW5pdEluZm8gPSBhd2FpdCBmcy5yZWFkSnNvbihwYXRoLmpvaW4oYmFzZVBhdGgsIElORk9fRE9UX0pTT04pKTtcbiAgICByZXR1cm4gbmV3IEluaXRUZW1wbGF0ZShiYXNlUGF0aCwgbmFtZSwgbGFuZ3VhZ2VzLCBpbml0SW5mbywgVGVtcGxhdGVUeXBlLkJVSUxUX0lOKTtcbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgYXN5bmMgZnJvbVBhdGgodGVtcGxhdGVQYXRoOiBzdHJpbmcpIHtcbiAgICBjb25zdCBiYXNlUGF0aCA9IHBhdGgucmVzb2x2ZSh0ZW1wbGF0ZVBhdGgpO1xuXG4gICAgaWYgKCFhd2FpdCBmcy5wYXRoRXhpc3RzKGJhc2VQYXRoKSkge1xuICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcihgVGVtcGxhdGUgcGF0aCBkb2VzIG5vdCBleGlzdDogJHtiYXNlUGF0aH1gKTtcbiAgICB9XG5cbiAgICBjb25zdCBsYW5ndWFnZXMgPSBhd2FpdCBnZXRMYW5ndWFnZURpcmVjdG9yaWVzKGJhc2VQYXRoKTtcbiAgICBjb25zdCBuYW1lID0gcGF0aC5iYXNlbmFtZShiYXNlUGF0aCk7XG5cbiAgICByZXR1cm4gbmV3IEluaXRUZW1wbGF0ZShiYXNlUGF0aCwgbmFtZSwgbGFuZ3VhZ2VzLCBudWxsLCBUZW1wbGF0ZVR5cGUuQ1VTVE9NKTtcbiAgfVxuXG4gIHB1YmxpYyByZWFkb25seSBkZXNjcmlwdGlvbj86IHN0cmluZztcbiAgcHVibGljIHJlYWRvbmx5IGFsaWFzZXMgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgcHVibGljIHJlYWRvbmx5IHRlbXBsYXRlVHlwZTogVGVtcGxhdGVUeXBlO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgYmFzZVBhdGg6IHN0cmluZyxcbiAgICBwdWJsaWMgcmVhZG9ubHkgbmFtZTogc3RyaW5nLFxuICAgIHB1YmxpYyByZWFkb25seSBsYW5ndWFnZXM6IHN0cmluZ1tdLFxuICAgIGluaXRJbmZvOiBUZW1wbGF0ZUluaXRJbmZvIHwgbnVsbCxcbiAgICB0ZW1wbGF0ZVR5cGU6IFRlbXBsYXRlVHlwZSxcbiAgKSB7XG4gICAgdGhpcy50ZW1wbGF0ZVR5cGUgPSB0ZW1wbGF0ZVR5cGU7XG4gICAgLy8gT25seSBidWlsdC1pbiB0ZW1wbGF0ZXMgaGF2ZSBkZXNjcmlwdGlvbnMgYW5kIGFsaWFzZXMgZnJvbSBpbmZvLmpzb25cbiAgICBpZiAodGVtcGxhdGVUeXBlID09PSBUZW1wbGF0ZVR5cGUuQlVJTFRfSU4gJiYgaW5pdEluZm8pIHtcbiAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSBpbml0SW5mby5kZXNjcmlwdGlvbjtcbiAgICAgIGZvciAoY29uc3QgYWxpYXMgb2YgaW5pdEluZm8uYWxpYXNlcyB8fCBbXSkge1xuICAgICAgICB0aGlzLmFsaWFzZXMuYWRkKGFsaWFzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIG5hbWUgLSB0aGUgbmFtZSB0aGF0IGlzIGJlaW5nIGNoZWNrZWRcbiAgICogQHJldHVybnMgYGB0cnVlYGAgaWYgYGBuYW1lYGAgaXMgdGhlIG5hbWUgb2YgdGhpcyB0ZW1wbGF0ZSBvciBhbiBhbGlhcyBvZiBpdC5cbiAgICovXG4gIHB1YmxpYyBoYXNOYW1lKG5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBuYW1lID09PSB0aGlzLm5hbWUgfHwgdGhpcy5hbGlhc2VzLmhhcyhuYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIHRoaXMgYGBJbml0VGVtcGxhdGVgYCBmb3IgYSBnaXZlbiBsYW5ndWFnZSB0byBhIHNwZWNpZmllZCBmb2xkZXIuXG4gICAqXG4gICAqIEBwYXJhbSBsYW5ndWFnZSAtIHRoZSBsYW5ndWFnZSB0byBpbnN0YW50aWF0ZSB0aGlzIHRlbXBsYXRlIHdpdGhcbiAgICogQHBhcmFtIHRhcmdldERpcmVjdG9yeSAtIHRoZSBkaXJlY3Rvcnkgd2hlcmUgdGhlIHRlbXBsYXRlIGlzIHRvIGJlIGluc3RhbnRpYXRlZCBpbnRvXG4gICAqIEBwYXJhbSBzdGFja05hbWUgLSB0aGUgbmFtZSBvZiB0aGUgc3RhY2sgdG8gY3JlYXRlXG4gICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuICAgKiBAcGFyYW0gbGliVmVyc2lvbiAtIHRoZSB2ZXJzaW9uIG9mIHRoZSBDREsgbGlicmFyeSB0byB1c2VcbiAgICogQGRlZmF1bHQgdW5kZWZpbmVkXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgaW5zdGFsbChpb0hlbHBlcjogSW9IZWxwZXIsIGxhbmd1YWdlOiBzdHJpbmcsIHRhcmdldERpcmVjdG9yeTogc3RyaW5nLCBzdGFja05hbWU/OiBzdHJpbmcsIGxpYlZlcnNpb24/OiBzdHJpbmcpIHtcbiAgICBpZiAodGhpcy5sYW5ndWFnZXMuaW5kZXhPZihsYW5ndWFnZSkgPT09IC0xKSB7XG4gICAgICBhd2FpdCBpb0hlbHBlci5kZWZhdWx0cy5lcnJvcihcbiAgICAgICAgYFRoZSAke2NoYWxrLmJsdWUobGFuZ3VhZ2UpfSBsYW5ndWFnZSBpcyBub3Qgc3VwcG9ydGVkIGZvciAke2NoYWxrLmdyZWVuKHRoaXMubmFtZSl9IGAgK1xuICAgICAgICAgIGAoaXQgc3VwcG9ydHM6ICR7dGhpcy5sYW5ndWFnZXMubWFwKChsKSA9PiBjaGFsay5ibHVlKGwpKS5qb2luKCcsICcpfSlgLFxuICAgICAgKTtcbiAgICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoYFVuc3VwcG9ydGVkIGxhbmd1YWdlOiAke2xhbmd1YWdlfWApO1xuICAgIH1cblxuICAgIGNvbnN0IHByb2plY3RJbmZvOiBQcm9qZWN0SW5mbyA9IHtcbiAgICAgIG5hbWU6IGRlY2FtZWxpemUocGF0aC5iYXNlbmFtZShwYXRoLnJlc29sdmUodGFyZ2V0RGlyZWN0b3J5KSkpLFxuICAgICAgc3RhY2tOYW1lLFxuICAgICAgdmVyc2lvbnM6IGF3YWl0IGxvYWRJbml0VmVyc2lvbnMoKSxcbiAgICB9O1xuXG4gICAgaWYgKGxpYlZlcnNpb24pIHtcbiAgICAgIHByb2plY3RJbmZvLnZlcnNpb25zWydhd3MtY2RrLWxpYiddID0gbGliVmVyc2lvbjtcbiAgICB9XG5cbiAgICBjb25zdCBzb3VyY2VEaXJlY3RvcnkgPSBwYXRoLmpvaW4odGhpcy5iYXNlUGF0aCwgbGFuZ3VhZ2UpO1xuXG4gICAgaWYgKHRoaXMudGVtcGxhdGVUeXBlID09PSBUZW1wbGF0ZVR5cGUuQ1VTVE9NKSB7XG4gICAgICAvLyBGb3IgY3VzdG9tIHRlbXBsYXRlcywgY29weSBmaWxlcyB3aXRob3V0IHByb2Nlc3NpbmcgcGxhY2Vob2xkZXJzXG4gICAgICBhd2FpdCB0aGlzLmluc3RhbGxGaWxlc1dpdGhvdXRQcm9jZXNzaW5nKHNvdXJjZURpcmVjdG9yeSwgdGFyZ2V0RGlyZWN0b3J5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRm9yIGJ1aWx0LWluIHRlbXBsYXRlcywgcHJvY2VzcyBwbGFjZWhvbGRlcnMgYXMgdXN1YWxcbiAgICAgIGF3YWl0IHRoaXMuaW5zdGFsbEZpbGVzKHNvdXJjZURpcmVjdG9yeSwgdGFyZ2V0RGlyZWN0b3J5LCBsYW5ndWFnZSwgcHJvamVjdEluZm8pO1xuICAgICAgYXdhaXQgdGhpcy5hcHBseUZ1dHVyZUZsYWdzKHRhcmdldERpcmVjdG9yeSk7XG4gICAgICBhd2FpdCBpbnZva2VCdWlsdGluSG9va3MoXG4gICAgICAgIGlvSGVscGVyLFxuICAgICAgICB7IHRhcmdldERpcmVjdG9yeSwgbGFuZ3VhZ2UsIHRlbXBsYXRlTmFtZTogdGhpcy5uYW1lIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBzdWJzdGl0dXRlUGxhY2Vob2xkZXJzSW46IGFzeW5jICguLi5maWxlTmFtZXM6IHN0cmluZ1tdKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmaWxlUHJvY2Vzc2luZ1Byb21pc2VzID0gZmlsZU5hbWVzLm1hcChhc3luYyAoZmlsZU5hbWUpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgZnVsbFBhdGggPSBwYXRoLmpvaW4odGFyZ2V0RGlyZWN0b3J5LCBmaWxlTmFtZSk7XG4gICAgICAgICAgICAgIGNvbnN0IHRlbXBsYXRlID0gYXdhaXQgZnMucmVhZEZpbGUoZnVsbFBhdGgsIHsgZW5jb2Rpbmc6ICd1dGYtOCcgfSk7XG4gICAgICAgICAgICAgIGF3YWl0IGZzLndyaXRlRmlsZShmdWxsUGF0aCwgZXhwYW5kUGxhY2Vob2xkZXJzKHRlbXBsYXRlLCBsYW5ndWFnZSwgcHJvamVjdEluZm8pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEBjZGtsYWJzL3Byb21pc2VhbGwtbm8tdW5ib3VuZGVkLXBhcmFsbGVsaXNtICovIC8vIFByb2Nlc3NpbmcgYSBzbWFsbCwga25vd24gc2V0IG9mIHRlbXBsYXRlIGZpbGVzXG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChmaWxlUHJvY2Vzc2luZ1Byb21pc2VzKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHBsYWNlaG9sZGVyOiAocGg6IHN0cmluZykgPT4gZXhwYW5kUGxhY2Vob2xkZXJzKGAlJHtwaH0lYCwgbGFuZ3VhZ2UsIHByb2plY3RJbmZvKSxcbiAgICAgICAgfSxcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBpbnN0YWxsRmlsZXMoc291cmNlRGlyZWN0b3J5OiBzdHJpbmcsIHRhcmdldERpcmVjdG9yeTogc3RyaW5nLCBsYW5ndWFnZTogc3RyaW5nLCBwcm9qZWN0OiBQcm9qZWN0SW5mbykge1xuICAgIGZvciAoY29uc3QgZmlsZSBvZiBhd2FpdCBmcy5yZWFkZGlyKHNvdXJjZURpcmVjdG9yeSkpIHtcbiAgICAgIGNvbnN0IGZyb21GaWxlID0gcGF0aC5qb2luKHNvdXJjZURpcmVjdG9yeSwgZmlsZSk7XG4gICAgICBjb25zdCB0b0ZpbGUgPSBwYXRoLmpvaW4odGFyZ2V0RGlyZWN0b3J5LCBleHBhbmRQbGFjZWhvbGRlcnMoZmlsZSwgbGFuZ3VhZ2UsIHByb2plY3QpKTtcbiAgICAgIGlmICgoYXdhaXQgZnMuc3RhdChmcm9tRmlsZSkpLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgYXdhaXQgZnMubWtkaXIodG9GaWxlKTtcbiAgICAgICAgYXdhaXQgdGhpcy5pbnN0YWxsRmlsZXMoZnJvbUZpbGUsIHRvRmlsZSwgbGFuZ3VhZ2UsIHByb2plY3QpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSBpZiAoZmlsZS5tYXRjaCgvXi4qXFwudGVtcGxhdGVcXC5bXi5dKyQvKSkge1xuICAgICAgICBhd2FpdCB0aGlzLmluc3RhbGxQcm9jZXNzZWQoZnJvbUZpbGUsIHRvRmlsZS5yZXBsYWNlKC9cXC50ZW1wbGF0ZShcXC5bXi5dKykkLywgJyQxJyksIGxhbmd1YWdlLCBwcm9qZWN0KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2UgaWYgKGZpbGUubWF0Y2goL14uKlxcLmhvb2tcXC4oZC4pP1teLl0rJC8pKSB7XG4gICAgICAgIC8vIElnbm9yZVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF3YWl0IGZzLmNvcHkoZnJvbUZpbGUsIHRvRmlsZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBpbnN0YWxsUHJvY2Vzc2VkKHRlbXBsYXRlUGF0aDogc3RyaW5nLCB0b0ZpbGU6IHN0cmluZywgbGFuZ3VhZ2U6IHN0cmluZywgcHJvamVjdDogUHJvamVjdEluZm8pIHtcbiAgICBjb25zdCB0ZW1wbGF0ZSA9IGF3YWl0IGZzLnJlYWRGaWxlKHRlbXBsYXRlUGF0aCwgeyBlbmNvZGluZzogJ3V0Zi04JyB9KTtcbiAgICBhd2FpdCBmcy53cml0ZUZpbGUodG9GaWxlLCBleHBhbmRQbGFjZWhvbGRlcnModGVtcGxhdGUsIGxhbmd1YWdlLCBwcm9qZWN0KSk7XG4gIH1cblxuICAvKipcbiAgICogQ29weSB0ZW1wbGF0ZSBmaWxlcyB3aXRob3V0IHByb2Nlc3NpbmcgcGxhY2Vob2xkZXJzIChmb3IgY3VzdG9tIHRlbXBsYXRlcylcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgaW5zdGFsbEZpbGVzV2l0aG91dFByb2Nlc3Npbmcoc291cmNlRGlyZWN0b3J5OiBzdHJpbmcsIHRhcmdldERpcmVjdG9yeTogc3RyaW5nKSB7XG4gICAgYXdhaXQgZnMuY29weShzb3VyY2VEaXJlY3RvcnksIHRhcmdldERpcmVjdG9yeSwge1xuICAgICAgZmlsdGVyOiAoc3JjOiBzdHJpbmcpID0+IHtcbiAgICAgICAgY29uc3QgZmlsZW5hbWUgPSBwYXRoLmJhc2VuYW1lKHNyYyk7XG4gICAgICAgIHJldHVybiAhZmlsZW5hbWUubWF0Y2goL14uKlxcLmhvb2tcXC4oZC4pP1teLl0rJC8pO1xuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGNvbnRleHQgdmFyaWFibGVzIHRvIGBjZGsuanNvbmAgaW4gdGhlIGdlbmVyYXRlZCBwcm9qZWN0IGRpcmVjdG9yeSB0b1xuICAgKiBlbmFibGUgZnV0dXJlIGJlaGF2aW9yIGZvciBuZXcgcHJvamVjdHMuXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGFwcGx5RnV0dXJlRmxhZ3MocHJvamVjdERpcjogc3RyaW5nKSB7XG4gICAgY29uc3QgY2RrSnNvbiA9IHBhdGguam9pbihwcm9qZWN0RGlyLCAnY2RrLmpzb24nKTtcbiAgICBpZiAoIShhd2FpdCBmcy5wYXRoRXhpc3RzKGNka0pzb24pKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbmZpZyA9IGF3YWl0IGZzLnJlYWRKc29uKGNka0pzb24pO1xuICAgIGNvbmZpZy5jb250ZXh0ID0ge1xuICAgICAgLi4uY29uZmlnLmNvbnRleHQsXG4gICAgICAuLi5hd2FpdCBjdXJyZW50bHlSZWNvbW1lbmRlZEF3c0Nka0xpYkZsYWdzKCksXG4gICAgfTtcblxuICAgIGF3YWl0IGZzLndyaXRlSnNvbihjZGtKc29uLCBjb25maWcsIHsgc3BhY2VzOiAyIH0pO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGFkZE1pZ3JhdGVDb250ZXh0KHByb2plY3REaXI6IHN0cmluZykge1xuICAgIGNvbnN0IGNka0pzb24gPSBwYXRoLmpvaW4ocHJvamVjdERpciwgJ2Nkay5qc29uJyk7XG4gICAgaWYgKCEoYXdhaXQgZnMucGF0aEV4aXN0cyhjZGtKc29uKSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBjb25maWcgPSBhd2FpdCBmcy5yZWFkSnNvbihjZGtKc29uKTtcbiAgICBjb25maWcuY29udGV4dCA9IHtcbiAgICAgIC4uLmNvbmZpZy5jb250ZXh0LFxuICAgICAgJ2Nkay1taWdyYXRlJzogdHJ1ZSxcbiAgICB9O1xuXG4gICAgYXdhaXQgZnMud3JpdGVKc29uKGNka0pzb24sIGNvbmZpZywgeyBzcGFjZXM6IDIgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4cGFuZFBsYWNlaG9sZGVycyh0ZW1wbGF0ZTogc3RyaW5nLCBsYW5ndWFnZTogc3RyaW5nLCBwcm9qZWN0OiBQcm9qZWN0SW5mbykge1xuICBjb25zdCBjZGtWZXJzaW9uID0gcHJvamVjdC52ZXJzaW9uc1snYXdzLWNkay1saWInXTtcbiAgY29uc3QgY2RrQ2xpVmVyc2lvbiA9IHByb2plY3QudmVyc2lvbnNbJ2F3cy1jZGsnXTtcbiAgbGV0IGNvbnN0cnVjdHNWZXJzaW9uID0gcHJvamVjdC52ZXJzaW9ucy5jb25zdHJ1Y3RzO1xuXG4gIHN3aXRjaCAobGFuZ3VhZ2UpIHtcbiAgICBjYXNlICdqYXZhJzpcbiAgICBjYXNlICdjc2hhcnAnOlxuICAgIGNhc2UgJ2ZzaGFycCc6XG4gICAgICBjb25zdHJ1Y3RzVmVyc2lvbiA9IHJhbmdlRnJvbVNlbXZlcihjb25zdHJ1Y3RzVmVyc2lvbiwgJ2JyYWNrZXQnKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3B5dGhvbic6XG4gICAgICBjb25zdHJ1Y3RzVmVyc2lvbiA9IHJhbmdlRnJvbVNlbXZlcihjb25zdHJ1Y3RzVmVyc2lvbiwgJ3BlcCcpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIHRlbXBsYXRlXG4gICAgLnJlcGxhY2UoLyVuYW1lJS9nLCBwcm9qZWN0Lm5hbWUpXG4gICAgLnJlcGxhY2UoLyVzdGFja25hbWUlLywgcHJvamVjdC5zdGFja05hbWUgPz8gJyVuYW1lLlBhc2NhbENhc2VkJVN0YWNrJylcbiAgICAucmVwbGFjZShcbiAgICAgIC8lUGFzY2FsTmFtZVNwYWNlJS8sXG4gICAgICBwcm9qZWN0LnN0YWNrTmFtZSA/IGNhbWVsQ2FzZShwcm9qZWN0LnN0YWNrTmFtZSArICdTdGFjaycsIHsgcGFzY2FsQ2FzZTogdHJ1ZSB9KSA6ICclbmFtZS5QYXNjYWxDYXNlZCUnLFxuICAgIClcbiAgICAucmVwbGFjZShcbiAgICAgIC8lUGFzY2FsU3RhY2tQcm9wcyUvLFxuICAgICAgcHJvamVjdC5zdGFja05hbWUgPyBjYW1lbENhc2UocHJvamVjdC5zdGFja05hbWUsIHsgcGFzY2FsQ2FzZTogdHJ1ZSB9KSArICdTdGFja1Byb3BzJyA6ICdTdGFja1Byb3BzJyxcbiAgICApXG4gICAgLnJlcGxhY2UoLyVuYW1lXFwuY2FtZWxDYXNlZCUvZywgY2FtZWxDYXNlKHByb2plY3QubmFtZSkpXG4gICAgLnJlcGxhY2UoLyVuYW1lXFwuUGFzY2FsQ2FzZWQlL2csIGNhbWVsQ2FzZShwcm9qZWN0Lm5hbWUsIHsgcGFzY2FsQ2FzZTogdHJ1ZSB9KSlcbiAgICAucmVwbGFjZSgvJWNkay12ZXJzaW9uJS9nLCBjZGtWZXJzaW9uKVxuICAgIC5yZXBsYWNlKC8lY2RrLWNsaS12ZXJzaW9uJS9nLCBjZGtDbGlWZXJzaW9uKVxuICAgIC5yZXBsYWNlKC8lY29uc3RydWN0cy12ZXJzaW9uJS9nLCBjb25zdHJ1Y3RzVmVyc2lvbilcbiAgICAucmVwbGFjZSgvJWNkay1ob21lJS9nLCBjZGtIb21lRGlyKCkpXG4gICAgLnJlcGxhY2UoLyVuYW1lXFwuUHl0aG9uTW9kdWxlJS9nLCBwcm9qZWN0Lm5hbWUucmVwbGFjZSgvLS9nLCAnXycpKVxuICAgIC5yZXBsYWNlKC8lcHl0aG9uLWV4ZWN1dGFibGUlL2csIHB5dGhvbkV4ZWN1dGFibGUoKSlcbiAgICAucmVwbGFjZSgvJW5hbWVcXC5TdGFja05hbWUlL2csIHByb2plY3QubmFtZS5yZXBsYWNlKC9bXkEtWmEtejAtOS1dL2csICctJykpO1xufVxuXG5pbnRlcmZhY2UgUHJvamVjdEluZm8ge1xuICAvKiogVGhlIHZhbHVlIHVzZWQgZm9yICVuYW1lJSAqL1xuICByZWFkb25seSBuYW1lOiBzdHJpbmc7XG4gIHJlYWRvbmx5IHN0YWNrTmFtZT86IHN0cmluZztcblxuICByZWFkb25seSB2ZXJzaW9uczogVmVyc2lvbnM7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhdmFpbGFibGVJbml0VGVtcGxhdGVzKCk6IFByb21pc2U8SW5pdFRlbXBsYXRlW10+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB0ZW1wbGF0ZXNEaXIgPSBwYXRoLmpvaW4oY2xpUm9vdERpcigpLCAnbGliJywgJ2luaXQtdGVtcGxhdGVzJyk7XG4gICAgY29uc3QgdGVtcGxhdGVOYW1lcyA9IGF3YWl0IGxpc3REaXJlY3RvcnkodGVtcGxhdGVzRGlyKTtcbiAgICBjb25zdCB0ZW1wbGF0ZVByb21pc2VzID0gdGVtcGxhdGVOYW1lcy5tYXAodGVtcGxhdGVOYW1lID0+XG4gICAgICBJbml0VGVtcGxhdGUuZnJvbU5hbWUodGVtcGxhdGVzRGlyLCB0ZW1wbGF0ZU5hbWUpLFxuICAgICk7XG4gICAgLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEBjZGtsYWJzL3Byb21pc2VhbGwtbm8tdW5ib3VuZGVkLXBhcmFsbGVsaXNtICovIC8vIEJ1aWx0LWluIHRlbXBsYXRlcyBhcmUgbGltaXRlZCBpbiBudW1iZXJcbiAgICByZXR1cm4gYXdhaXQgUHJvbWlzZS5hbGwodGVtcGxhdGVQcm9taXNlcyk7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAvLyBSZXR1cm4gZW1wdHkgYXJyYXkgaWYgdGVtcGxhdGVzIGRpcmVjdG9yeSBkb2Vzbid0IGV4aXN0IG9yIGNhbid0IGJlIHJlYWRcbiAgICAvLyBUaGlzIGFsbG93cyB0aGUgQ0xJIHRvIGdyYWNlZnVsbHkgaGFuZGxlIG1pc3NpbmcgYnVpbHQtaW4gdGVtcGxhdGVzXG4gICAgaWYgKGVycm9yLmNvZGUgPT09ICdFTk9FTlQnIHx8IGVycm9yLmNvZGUgPT09ICdFQUNDRVMnKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhdmFpbGFibGVJbml0TGFuZ3VhZ2VzKCk6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgY29uc3QgdGVtcGxhdGVzID0gYXdhaXQgYXZhaWxhYmxlSW5pdFRlbXBsYXRlcygpO1xuICBjb25zdCByZXN1bHQgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgZm9yIChjb25zdCB0ZW1wbGF0ZSBvZiB0ZW1wbGF0ZXMpIHtcbiAgICBmb3IgKGNvbnN0IGxhbmd1YWdlIG9mIHRlbXBsYXRlLmxhbmd1YWdlcykge1xuICAgICAgY29uc3QgYWxpYXMgPSBnZXRMYW5ndWFnZUFsaWFzKGxhbmd1YWdlKTtcbiAgICAgIHJlc3VsdC5hZGQobGFuZ3VhZ2UpO1xuICAgICAgYWxpYXMgJiYgcmVzdWx0LmFkZChhbGlhcyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBbLi4ucmVzdWx0XTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gZGlyUGF0aCAtIGlzIHRoZSBkaXJlY3RvcnkgdG8gYmUgbGlzdGVkLlxuICogQHJldHVybnMgdGhlIGxpc3Qgb2YgZmlsZSBvciBkaXJlY3RvcnkgbmFtZXMgY29udGFpbmVkIGluIGBgZGlyUGF0aGBgLCBleGNsdWRpbmcgYW55IGRvdC1maWxlLCBhbmQgc29ydGVkLlxuICovXG5hc3luYyBmdW5jdGlvbiBsaXN0RGlyZWN0b3J5KGRpclBhdGg6IHN0cmluZykge1xuICByZXR1cm4gKFxuICAgIChhd2FpdCBmcy5yZWFkZGlyKGRpclBhdGgpKVxuICAgICAgLmZpbHRlcigocCkgPT4gIXAuc3RhcnRzV2l0aCgnLicpKVxuICAgICAgLmZpbHRlcigocCkgPT4gIShwID09PSAnTElDRU5TRScpKVxuICAgICAgLy8gaWYsIGZvciBzb21lIHJlYXNvbiwgdGhlIHRlbXAgZm9sZGVyIGZvciB0aGUgaG9vayBkb2Vzbid0IGdldCBkZWxldGVkIHdlIGRvbid0IHdhbnQgdG8gZGlzcGxheSBpdCBpbiB0aGlzIGxpc3RcbiAgICAgIC5maWx0ZXIoKHApID0+ICEocCA9PT0gSU5GT19ET1RfSlNPTikpXG4gICAgICAuc29ydCgpXG4gICk7XG59XG5cbi8qKlxuICogUHJpbnQgYXZhaWxhYmxlIHRlbXBsYXRlcyB0byB0aGUgdXNlclxuICogQHBhcmFtIGlvSGVscGVyIC0gSU8gaGVscGVyIGZvciB1c2VyIGludGVyYWN0aW9uXG4gKiBAcGFyYW0gbGFuZ3VhZ2UgLSBQcm9ncmFtbWluZyBsYW5ndWFnZSBmaWx0ZXJcbiAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJpbnRBdmFpbGFibGVUZW1wbGF0ZXMoaW9IZWxwZXI6IElvSGVscGVyLCBsYW5ndWFnZT86IHN0cmluZykge1xuICBhd2FpdCBpb0hlbHBlci5kZWZhdWx0cy5pbmZvKCdBdmFpbGFibGUgdGVtcGxhdGVzOicpO1xuICBmb3IgKGNvbnN0IHRlbXBsYXRlIG9mIGF3YWl0IGF2YWlsYWJsZUluaXRUZW1wbGF0ZXMoKSkge1xuICAgIGlmIChsYW5ndWFnZSAmJiB0ZW1wbGF0ZS5sYW5ndWFnZXMuaW5kZXhPZihsYW5ndWFnZSkgPT09IC0xKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgYXdhaXQgaW9IZWxwZXIuZGVmYXVsdHMuaW5mbyhgKiAke2NoYWxrLmdyZWVuKHRlbXBsYXRlLm5hbWUpfTogJHt0ZW1wbGF0ZS5kZXNjcmlwdGlvbiF9YCk7XG4gICAgY29uc3QgbGFuZ3VhZ2VBcmcgPSBsYW5ndWFnZVxuICAgICAgPyBjaGFsay5ib2xkKGxhbmd1YWdlKVxuICAgICAgOiB0ZW1wbGF0ZS5sYW5ndWFnZXMubGVuZ3RoID4gMVxuICAgICAgICA/IGBbJHt0ZW1wbGF0ZS5sYW5ndWFnZXMubWFwKCh0KSA9PiBjaGFsay5ib2xkKHQpKS5qb2luKCd8Jyl9XWBcbiAgICAgICAgOiBjaGFsay5ib2xkKHRlbXBsYXRlLmxhbmd1YWdlc1swXSk7XG4gICAgYXdhaXQgaW9IZWxwZXIuZGVmYXVsdHMuaW5mbyhgICAg4pSU4pSAICR7Y2hhbGsuYmx1ZShgY2RrIGluaXQgJHtjaGFsay5ib2xkKHRlbXBsYXRlLm5hbWUpfSAtLWxhbmd1YWdlPSR7bGFuZ3VhZ2VBcmd9YCl9YCk7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gaW5pdGlhbGl6ZVByb2plY3QoXG4gIGlvSGVscGVyOiBJb0hlbHBlcixcbiAgdGVtcGxhdGU6IEluaXRUZW1wbGF0ZSxcbiAgbGFuZ3VhZ2U6IHN0cmluZyxcbiAgY2FuVXNlTmV0d29yazogYm9vbGVhbixcbiAgZ2VuZXJhdGVPbmx5OiBib29sZWFuLFxuICB3b3JrRGlyOiBzdHJpbmcsXG4gIHN0YWNrTmFtZT86IHN0cmluZyxcbiAgbWlncmF0ZT86IGJvb2xlYW4sXG4gIGNka1ZlcnNpb24/OiBzdHJpbmcsXG4pIHtcbiAgLy8gU3RlcCAxOiBFbnN1cmUgdGFyZ2V0IGRpcmVjdG9yeSBpcyBlbXB0eVxuICBhd2FpdCBhc3NlcnRJc0VtcHR5RGlyZWN0b3J5KHdvcmtEaXIpO1xuXG4gIC8vIFN0ZXAgMjogQ29weSB0ZW1wbGF0ZSBmaWxlc1xuICBhd2FpdCBpb0hlbHBlci5kZWZhdWx0cy5pbmZvKGBBcHBseWluZyBwcm9qZWN0IHRlbXBsYXRlICR7Y2hhbGsuZ3JlZW4odGVtcGxhdGUubmFtZSl9IGZvciAke2NoYWxrLmJsdWUobGFuZ3VhZ2UpfWApO1xuICBhd2FpdCB0ZW1wbGF0ZS5pbnN0YWxsKGlvSGVscGVyLCBsYW5ndWFnZSwgd29ya0Rpciwgc3RhY2tOYW1lLCBjZGtWZXJzaW9uKTtcblxuICBpZiAobWlncmF0ZSkge1xuICAgIGF3YWl0IHRlbXBsYXRlLmFkZE1pZ3JhdGVDb250ZXh0KHdvcmtEaXIpO1xuICB9XG5cbiAgaWYgKGF3YWl0IGZzLnBhdGhFeGlzdHMoYCR7d29ya0Rpcn0vUkVBRE1FLm1kYCkpIHtcbiAgICBjb25zdCByZWFkbWUgPSBhd2FpdCBmcy5yZWFkRmlsZShgJHt3b3JrRGlyfS9SRUFETUUubWRgLCB7IGVuY29kaW5nOiAndXRmLTgnIH0pO1xuICAgIGF3YWl0IGlvSGVscGVyLmRlZmF1bHRzLmluZm8oY2hhbGsuZ3JlZW4ocmVhZG1lKSk7XG4gIH1cblxuICBpZiAoIWdlbmVyYXRlT25seSkge1xuICAgIC8vIFN0ZXAgMzogSW5pdGlhbGl6ZSBHaXQgcmVwb3NpdG9yeSBhbmQgY3JlYXRlIGluaXRpYWwgY29tbWl0XG4gICAgYXdhaXQgaW5pdGlhbGl6ZUdpdFJlcG9zaXRvcnkoaW9IZWxwZXIsIHdvcmtEaXIpO1xuXG4gICAgLy8gU3RlcCA0OiBQb3N0LWluc3RhbGwgc3RlcHNcbiAgICBhd2FpdCBwb3N0SW5zdGFsbChpb0hlbHBlciwgbGFuZ3VhZ2UsIGNhblVzZU5ldHdvcmssIHdvcmtEaXIpO1xuICB9XG5cbiAgYXdhaXQgaW9IZWxwZXIuZGVmYXVsdHMuaW5mbygn4pyFIEFsbCBkb25lIScpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBhc3NlcnRJc0VtcHR5RGlyZWN0b3J5KHdvcmtEaXI6IHN0cmluZykge1xuICB0cnkge1xuICAgIGNvbnN0IGZpbGVzID0gYXdhaXQgZnMucmVhZGRpcih3b3JrRGlyKTtcbiAgICBpZiAoZmlsZXMuZmlsdGVyKChmKSA9PiAhZi5zdGFydHNXaXRoKCcuJykpLmxlbmd0aCAhPT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcignYGNkayBpbml0YCBjYW5ub3QgYmUgcnVuIGluIGEgbm9uLWVtcHR5IGRpcmVjdG9yeSEnKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgIGlmIChlLmNvZGUgPT09ICdFTk9FTlQnKSB7XG4gICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKGBEaXJlY3RvcnkgZG9lcyBub3QgZXhpc3Q6ICR7d29ya0Rpcn0uIFBsZWFzZSBjcmVhdGUgdGhlIGRpcmVjdG9yeSBmaXJzdC5gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gaW5pdGlhbGl6ZUdpdFJlcG9zaXRvcnkoaW9IZWxwZXI6IElvSGVscGVyLCB3b3JrRGlyOiBzdHJpbmcpIHtcbiAgaWYgKGF3YWl0IGlzSW5HaXRSZXBvc2l0b3J5KHdvcmtEaXIpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGF3YWl0IGlvSGVscGVyLmRlZmF1bHRzLmluZm8oJ0luaXRpYWxpemluZyBhIG5ldyBnaXQgcmVwb3NpdG9yeS4uLicpO1xuICB0cnkge1xuICAgIGF3YWl0IGV4ZWN1dGUoaW9IZWxwZXIsICdnaXQnLCBbJ2luaXQnXSwgeyBjd2Q6IHdvcmtEaXIgfSk7XG4gICAgYXdhaXQgZXhlY3V0ZShpb0hlbHBlciwgJ2dpdCcsIFsnYWRkJywgJy4nXSwgeyBjd2Q6IHdvcmtEaXIgfSk7XG4gICAgYXdhaXQgZXhlY3V0ZShpb0hlbHBlciwgJ2dpdCcsIFsnY29tbWl0JywgJy0tbWVzc2FnZT1cIkluaXRpYWwgY29tbWl0XCInLCAnLS1uby1ncGctc2lnbiddLCB7IGN3ZDogd29ya0RpciB9KTtcbiAgfSBjYXRjaCB7XG4gICAgYXdhaXQgaW9IZWxwZXIuZGVmYXVsdHMud2FybignVW5hYmxlIHRvIGluaXRpYWxpemUgZ2l0IHJlcG9zaXRvcnkgZm9yIHlvdXIgcHJvamVjdC4nKTtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBwb3N0SW5zdGFsbChpb0hlbHBlcjogSW9IZWxwZXIsIGxhbmd1YWdlOiBzdHJpbmcsIGNhblVzZU5ldHdvcms6IGJvb2xlYW4sIHdvcmtEaXI6IHN0cmluZykge1xuICBzd2l0Y2ggKGxhbmd1YWdlKSB7XG4gICAgY2FzZSAnamF2YXNjcmlwdCc6XG4gICAgICByZXR1cm4gcG9zdEluc3RhbGxKYXZhc2NyaXB0KGlvSGVscGVyLCBjYW5Vc2VOZXR3b3JrLCB3b3JrRGlyKTtcbiAgICBjYXNlICd0eXBlc2NyaXB0JzpcbiAgICAgIHJldHVybiBwb3N0SW5zdGFsbFR5cGVzY3JpcHQoaW9IZWxwZXIsIGNhblVzZU5ldHdvcmssIHdvcmtEaXIpO1xuICAgIGNhc2UgJ2phdmEnOlxuICAgICAgcmV0dXJuIHBvc3RJbnN0YWxsSmF2YShpb0hlbHBlciwgY2FuVXNlTmV0d29yaywgd29ya0Rpcik7XG4gICAgY2FzZSAncHl0aG9uJzpcbiAgICAgIHJldHVybiBwb3N0SW5zdGFsbFB5dGhvbihpb0hlbHBlciwgd29ya0Rpcik7XG4gICAgY2FzZSAnZ28nOlxuICAgICAgcmV0dXJuIHBvc3RJbnN0YWxsR28oaW9IZWxwZXIsIGNhblVzZU5ldHdvcmssIHdvcmtEaXIpO1xuICAgIGNhc2UgJ2NzaGFycCc6XG4gICAgICByZXR1cm4gcG9zdEluc3RhbGxDU2hhcnAoaW9IZWxwZXIsIGNhblVzZU5ldHdvcmssIHdvcmtEaXIpO1xuICAgIGNhc2UgJ2ZzaGFycCc6XG4gICAgICByZXR1cm4gcG9zdEluc3RhbGxGU2hhcnAoaW9IZWxwZXIsIGNhblVzZU5ldHdvcmssIHdvcmtEaXIpO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHBvc3RJbnN0YWxsSmF2YXNjcmlwdChpb0hlbHBlcjogSW9IZWxwZXIsIGNhblVzZU5ldHdvcms6IGJvb2xlYW4sIGN3ZDogc3RyaW5nKSB7XG4gIHJldHVybiBwb3N0SW5zdGFsbFR5cGVzY3JpcHQoaW9IZWxwZXIsIGNhblVzZU5ldHdvcmssIGN3ZCk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHBvc3RJbnN0YWxsVHlwZXNjcmlwdChpb0hlbHBlcjogSW9IZWxwZXIsIGNhblVzZU5ldHdvcms6IGJvb2xlYW4sIGN3ZDogc3RyaW5nKSB7XG4gIGNvbnN0IGNvbW1hbmQgPSAnbnBtJztcblxuICBpZiAoIWNhblVzZU5ldHdvcmspIHtcbiAgICBhd2FpdCBpb0hlbHBlci5kZWZhdWx0cy53YXJuKGBQbGVhc2UgcnVuICcke2NvbW1hbmR9IGluc3RhbGwnIWApO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGF3YWl0IGlvSGVscGVyLmRlZmF1bHRzLmluZm8oYEV4ZWN1dGluZyAke2NoYWxrLmdyZWVuKGAke2NvbW1hbmR9IGluc3RhbGxgKX0uLi5gKTtcbiAgdHJ5IHtcbiAgICBhd2FpdCBleGVjdXRlKGlvSGVscGVyLCBjb21tYW5kLCBbJ2luc3RhbGwnXSwgeyBjd2QgfSk7XG4gIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgIGF3YWl0IGlvSGVscGVyLmRlZmF1bHRzLndhcm4oYCR7Y29tbWFuZH0gaW5zdGFsbCBmYWlsZWQ6IGAgKyBmb3JtYXRFcnJvck1lc3NhZ2UoZSkpO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHBvc3RJbnN0YWxsSmF2YShpb0hlbHBlcjogSW9IZWxwZXIsIGNhblVzZU5ldHdvcms6IGJvb2xlYW4sIGN3ZDogc3RyaW5nKSB7XG4gIC8vIENoZWNrIGlmIHRoaXMgaXMgYSBHcmFkbGUgb3IgTWF2ZW4gcHJvamVjdFxuICBjb25zdCBoYXNHcmFkbGVCdWlsZCA9IGF3YWl0IGZzLnBhdGhFeGlzdHMocGF0aC5qb2luKGN3ZCwgJ2J1aWxkLmdyYWRsZScpKTtcbiAgY29uc3QgaGFzTWF2ZW5Qb20gPSBhd2FpdCBmcy5wYXRoRXhpc3RzKHBhdGguam9pbihjd2QsICdwb20ueG1sJykpO1xuXG4gIGlmIChoYXNHcmFkbGVCdWlsZCkge1xuICAgIC8vIEdyYWRsZSBwcm9qZWN0XG4gICAgY29uc3QgZ3JhZGxlV2FybmluZyA9IFwiUGxlYXNlIHJ1biAnLi9ncmFkbGV3IGJ1aWxkJyFcIjtcbiAgICBpZiAoIWNhblVzZU5ldHdvcmspIHtcbiAgICAgIGF3YWl0IGlvSGVscGVyLmRlZmF1bHRzLndhcm4oZ3JhZGxlV2FybmluZyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgYXdhaXQgaW9IZWxwZXIuZGVmYXVsdHMuaW5mbyhcIkV4ZWN1dGluZyAnLi9ncmFkbGV3IGJ1aWxkJ1wiKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgZXhlY3V0ZShpb0hlbHBlciwgJy4vZ3JhZGxldycsIFsnYnVpbGQnXSwgeyBjd2QgfSk7XG4gICAgfSBjYXRjaCB7XG4gICAgICBhd2FpdCBpb0hlbHBlci5kZWZhdWx0cy53YXJuKCdVbmFibGUgdG8gYnVpbGQgR3JhZGxlIHByb2plY3QnKTtcbiAgICAgIGF3YWl0IGlvSGVscGVyLmRlZmF1bHRzLndhcm4oZ3JhZGxlV2FybmluZyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGhhc01hdmVuUG9tKSB7XG4gICAgLy8gTWF2ZW4gcHJvamVjdFxuICAgIGNvbnN0IG12blBhY2thZ2VXYXJuaW5nID0gXCJQbGVhc2UgcnVuICdtdm4gcGFja2FnZSchXCI7XG4gICAgaWYgKCFjYW5Vc2VOZXR3b3JrKSB7XG4gICAgICBhd2FpdCBpb0hlbHBlci5kZWZhdWx0cy53YXJuKG12blBhY2thZ2VXYXJuaW5nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBhd2FpdCBpb0hlbHBlci5kZWZhdWx0cy5pbmZvKFwiRXhlY3V0aW5nICdtdm4gcGFja2FnZSdcIik7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGV4ZWN1dGUoaW9IZWxwZXIsICdtdm4nLCBbJ3BhY2thZ2UnXSwgeyBjd2QgfSk7XG4gICAgfSBjYXRjaCB7XG4gICAgICBhd2FpdCBpb0hlbHBlci5kZWZhdWx0cy53YXJuKCdVbmFibGUgdG8gcGFja2FnZSBjb21waWxlZCBjb2RlIGFzIEpBUicpO1xuICAgICAgYXdhaXQgaW9IZWxwZXIuZGVmYXVsdHMud2Fybihtdm5QYWNrYWdlV2FybmluZyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIE5vIHJlY29nbml6ZWQgYnVpbGQgZmlsZVxuICAgIGF3YWl0IGlvSGVscGVyLmRlZmF1bHRzLndhcm4oJ05vIGJ1aWxkLmdyYWRsZSBvciBwb20ueG1sIGZvdW5kLiBQbGVhc2Ugc2V0IHVwIHlvdXIgYnVpbGQgc3lzdGVtIG1hbnVhbGx5LicpO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHBvc3RJbnN0YWxsUHl0aG9uKGlvSGVscGVyOiBJb0hlbHBlciwgY3dkOiBzdHJpbmcpIHtcbiAgY29uc3QgcHl0aG9uID0gcHl0aG9uRXhlY3V0YWJsZSgpO1xuXG4gIC8vIENoZWNrIGlmIHJlcXVpcmVtZW50cy50eHQgZXhpc3RzXG4gIGNvbnN0IGhhc1JlcXVpcmVtZW50cyA9IGF3YWl0IGZzLnBhdGhFeGlzdHMocGF0aC5qb2luKGN3ZCwgJ3JlcXVpcmVtZW50cy50eHQnKSk7XG5cbiAgaWYgKGhhc1JlcXVpcmVtZW50cykge1xuICAgIGF3YWl0IGlvSGVscGVyLmRlZmF1bHRzLmluZm8oYEV4ZWN1dGluZyAke2NoYWxrLmdyZWVuKCdDcmVhdGluZyB2aXJ0dWFsZW52Li4uJyl9YCk7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGV4ZWN1dGUoaW9IZWxwZXIsIHB5dGhvbiwgWyctbScsICd2ZW52JywgJy52ZW52J10sIHsgY3dkIH0pO1xuICAgICAgYXdhaXQgaW9IZWxwZXIuZGVmYXVsdHMuaW5mbyhgRXhlY3V0aW5nICR7Y2hhbGsuZ3JlZW4oJ0luc3RhbGxpbmcgZGVwZW5kZW5jaWVzLi4uJyl9YCk7XG4gICAgICAvLyBJbnN0YWxsIGRlcGVuZGVuY2llcyBpbiB0aGUgdmlydHVhbCBlbnZpcm9ubWVudFxuICAgICAgY29uc3QgcGlwUGF0aCA9IHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicgPyAnLnZlbnZcXFxcU2NyaXB0c1xcXFxwaXAnIDogJy52ZW52L2Jpbi9waXAnO1xuICAgICAgYXdhaXQgZXhlY3V0ZShpb0hlbHBlciwgcGlwUGF0aCwgWydpbnN0YWxsJywgJy1yJywgJ3JlcXVpcmVtZW50cy50eHQnXSwgeyBjd2QgfSk7XG4gICAgfSBjYXRjaCB7XG4gICAgICBhd2FpdCBpb0hlbHBlci5kZWZhdWx0cy53YXJuKCdVbmFibGUgdG8gY3JlYXRlIHZpcnR1YWxlbnYgb3IgaW5zdGFsbCBkZXBlbmRlbmNpZXMgYXV0b21hdGljYWxseScpO1xuICAgICAgYXdhaXQgaW9IZWxwZXIuZGVmYXVsdHMud2FybihgUGxlYXNlIHJ1biAnJHtweXRob259IC1tIHZlbnYgLnZlbnYgJiYgLnZlbnYvYmluL3BpcCBpbnN0YWxsIC1yIHJlcXVpcmVtZW50cy50eHQnIWApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBhd2FpdCBpb0hlbHBlci5kZWZhdWx0cy53YXJuKCdObyByZXF1aXJlbWVudHMudHh0IGZvdW5kLiBQbGVhc2Ugc2V0IHVwIHlvdXIgUHl0aG9uIGVudmlyb25tZW50IG1hbnVhbGx5LicpO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHBvc3RJbnN0YWxsR28oaW9IZWxwZXI6IElvSGVscGVyLCBjYW5Vc2VOZXR3b3JrOiBib29sZWFuLCBjd2Q6IHN0cmluZykge1xuICBpZiAoIWNhblVzZU5ldHdvcmspIHtcbiAgICBhd2FpdCBpb0hlbHBlci5kZWZhdWx0cy53YXJuKCdQbGVhc2UgcnVuIFxcJ2dvIG1vZCB0aWR5XFwnIScpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGF3YWl0IGlvSGVscGVyLmRlZmF1bHRzLmluZm8oYEV4ZWN1dGluZyAke2NoYWxrLmdyZWVuKCdnbyBtb2QgdGlkeScpfS4uLmApO1xuICB0cnkge1xuICAgIGF3YWl0IGV4ZWN1dGUoaW9IZWxwZXIsICdnbycsIFsnbW9kJywgJ3RpZHknXSwgeyBjd2QgfSk7XG4gIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgIGF3YWl0IGlvSGVscGVyLmRlZmF1bHRzLndhcm4oJ1xcJ2dvIG1vZCB0aWR5XFwnIGZhaWxlZDogJyArIGZvcm1hdEVycm9yTWVzc2FnZShlKSk7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gcG9zdEluc3RhbGxDU2hhcnAoaW9IZWxwZXI6IElvSGVscGVyLCBjYW5Vc2VOZXR3b3JrOiBib29sZWFuLCBjd2Q6IHN0cmluZykge1xuICBjb25zdCBkb3RuZXRXYXJuaW5nID0gXCJQbGVhc2UgcnVuICdkb3RuZXQgcmVzdG9yZSAmJiBkb3RuZXQgYnVpbGQnIVwiO1xuICBpZiAoIWNhblVzZU5ldHdvcmspIHtcbiAgICBhd2FpdCBpb0hlbHBlci5kZWZhdWx0cy53YXJuKGRvdG5ldFdhcm5pbmcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGF3YWl0IGlvSGVscGVyLmRlZmF1bHRzLmluZm8oYEV4ZWN1dGluZyAke2NoYWxrLmdyZWVuKCdkb3RuZXQgcmVzdG9yZScpfS4uLmApO1xuICB0cnkge1xuICAgIGF3YWl0IGV4ZWN1dGUoaW9IZWxwZXIsICdkb3RuZXQnLCBbJ3Jlc3RvcmUnXSwgeyBjd2QgfSk7XG4gICAgYXdhaXQgaW9IZWxwZXIuZGVmYXVsdHMuaW5mbyhgRXhlY3V0aW5nICR7Y2hhbGsuZ3JlZW4oJ2RvdG5ldCBidWlsZCcpfS4uLmApO1xuICAgIGF3YWl0IGV4ZWN1dGUoaW9IZWxwZXIsICdkb3RuZXQnLCBbJ2J1aWxkJ10sIHsgY3dkIH0pO1xuICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICBhd2FpdCBpb0hlbHBlci5kZWZhdWx0cy53YXJuKCdVbmFibGUgdG8gcmVzdG9yZS9idWlsZCAuTkVUIHByb2plY3Q6ICcgKyBmb3JtYXRFcnJvck1lc3NhZ2UoZSkpO1xuICAgIGF3YWl0IGlvSGVscGVyLmRlZmF1bHRzLndhcm4oZG90bmV0V2FybmluZyk7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gcG9zdEluc3RhbGxGU2hhcnAoaW9IZWxwZXI6IElvSGVscGVyLCBjYW5Vc2VOZXR3b3JrOiBib29sZWFuLCBjd2Q6IHN0cmluZykge1xuICAvLyBGIyB1c2VzIHRoZSBzYW1lIGJ1aWxkIHN5c3RlbSBhcyBDI1xuICByZXR1cm4gcG9zdEluc3RhbGxDU2hhcnAoaW9IZWxwZXIsIGNhblVzZU5ldHdvcmssIGN3ZCk7XG59XG5cbi8qKlxuICogQHBhcmFtIGRpciAtIGEgZGlyZWN0b3J5IHRvIGJlIGNoZWNrZWRcbiAqIEByZXR1cm5zIHRydWUgaWYgYGBkaXJgYCBpcyB3aXRoaW4gYSBnaXQgcmVwb3NpdG9yeS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gaXNJbkdpdFJlcG9zaXRvcnkoZGlyOiBzdHJpbmcpIHtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAoYXdhaXQgZnMucGF0aEV4aXN0cyhwYXRoLmpvaW4oZGlyLCAnLmdpdCcpKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChpc1Jvb3QoZGlyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBkaXIgPSBwYXRoLmRpcm5hbWUoZGlyKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSBkaXIgLSBhIGRpcmVjdG9yeSB0byBiZSBjaGVja2VkLlxuICogQHJldHVybnMgdHJ1ZSBpZiBgYGRpcmBgIGlzIHRoZSByb290IG9mIGEgZmlsZXN5c3RlbS5cbiAqL1xuZnVuY3Rpb24gaXNSb290KGRpcjogc3RyaW5nKSB7XG4gIHJldHVybiBwYXRoLmRpcm5hbWUoZGlyKSA9PT0gZGlyO1xufVxuXG4vKipcbiAqIEV4ZWN1dGVzIGBjb21tYW5kYC4gU1RERVJSIGlzIGVtaXR0ZWQgaW4gcmVhbC10aW1lLlxuICpcbiAqIElmIGNvbW1hbmQgZXhpdHMgd2l0aCBub24temVybyBleGl0IGNvZGUsIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gYW5kIGluY2x1ZGVzXG4gKiB0aGUgY29udGVudHMgb2YgU1RET1VULlxuICpcbiAqIEByZXR1cm5zIFNURE9VVCAoaWYgc3VjY2Vzc2Z1bCkuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGV4ZWN1dGUoaW9IZWxwZXI6IElvSGVscGVyLCBjbWQ6IHN0cmluZywgYXJnczogc3RyaW5nW10sIHsgY3dkIH06IHsgY3dkOiBzdHJpbmcgfSkge1xuICBjb25zdCBjaGlsZCA9IGNoaWxkUHJvY2Vzcy5zcGF3bihjbWQsIGFyZ3MsIHtcbiAgICBjd2QsXG4gICAgc2hlbGw6IHRydWUsXG4gICAgc3RkaW86IFsnaWdub3JlJywgJ3BpcGUnLCAnaW5oZXJpdCddLFxuICB9KTtcbiAgbGV0IHN0ZG91dCA9ICcnO1xuICBjaGlsZC5zdGRvdXQub24oJ2RhdGEnLCAoY2h1bmspID0+IChzdGRvdXQgKz0gY2h1bmsudG9TdHJpbmcoKSkpO1xuICByZXR1cm4gbmV3IFByb21pc2U8c3RyaW5nPigob2ssIGZhaWwpID0+IHtcbiAgICBjaGlsZC5vbmNlKCdlcnJvcicsIChlcnIpID0+IGZhaWwoZXJyKSk7XG4gICAgY2hpbGQub25jZSgnZXhpdCcsIChzdGF0dXMpID0+IHtcbiAgICAgIGlmIChzdGF0dXMgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG9rKHN0ZG91dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFpbChuZXcgVG9vbGtpdEVycm9yKGAke2NtZH0gZXhpdGVkIHdpdGggc3RhdHVzICR7c3RhdHVzfWApKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSkuY2F0Y2goYXN5bmMgKGVycikgPT4ge1xuICAgIGF3YWl0IGlvSGVscGVyLmRlZmF1bHRzLmVycm9yKHN0ZG91dCk7XG4gICAgdGhyb3cgZXJyO1xuICB9KTtcbn1cblxuaW50ZXJmYWNlIFZlcnNpb25zIHtcbiAgWydhd3MtY2RrJ106IHN0cmluZztcbiAgWydhd3MtY2RrLWxpYiddOiBzdHJpbmc7XG4gIGNvbnN0cnVjdHM6IHN0cmluZztcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlICdhd3MtY2RrLWxpYicgdmVyc2lvbiB3ZSB3aWxsIGluaXRcbiAqXG4gKiBUaGlzIGhhcyBiZWVuIGJ1aWx0IGludG8gdGhlIENMSSBhdCBidWlsZCB0aW1lLlxuICovXG5hc3luYyBmdW5jdGlvbiBsb2FkSW5pdFZlcnNpb25zKCk6IFByb21pc2U8VmVyc2lvbnM+IHtcbiAgY29uc3QgaW5pdFZlcnNpb25GaWxlID0gcGF0aC5qb2luKGNsaVJvb3REaXIoKSwgJ2xpYicsICdpbml0LXRlbXBsYXRlcycsICcuaW5pdC12ZXJzaW9uLmpzb24nKTtcbiAgY29uc3QgY29udGVudHMgPSBKU09OLnBhcnNlKGF3YWl0IGZzLnJlYWRGaWxlKGluaXRWZXJzaW9uRmlsZSwgeyBlbmNvZGluZzogJ3V0Zi04JyB9KSk7XG5cbiAgY29uc3QgcmV0ID0ge1xuICAgICdhd3MtY2RrLWxpYic6IGNvbnRlbnRzWydhd3MtY2RrLWxpYiddLFxuICAgICdjb25zdHJ1Y3RzJzogY29udGVudHMuY29uc3RydWN0cyxcbiAgICAnYXdzLWNkayc6IHZlcnNpb25OdW1iZXIoKSxcbiAgfTtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocmV0KSkge1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIHRocm93IG5ldyBUb29sa2l0RXJyb3IoYE1pc3NpbmcgaW5pdCB2ZXJzaW9uIGZyb20gJHtpbml0VmVyc2lvbkZpbGV9OiAke2tleX1gKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgY3VycmVudGx5IHJlY29tbWVuZGVkIGZsYWdzIGZvciBgYXdzLWNkay1saWJgLlxuICpcbiAqIFRoZXNlIGhhdmUgYmVlbiBidWlsdCBpbnRvIHRoZSBDTEkgYXQgYnVpbGQgdGltZS5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGN1cnJlbnRseVJlY29tbWVuZGVkQXdzQ2RrTGliRmxhZ3MoKSB7XG4gIGNvbnN0IHJlY29tbWVuZGVkRmxhZ3NGaWxlID0gcGF0aC5qb2luKGNsaVJvb3REaXIoKSwgJ2xpYicsICdpbml0LXRlbXBsYXRlcycsICcucmVjb21tZW5kZWQtZmVhdHVyZS1mbGFncy5qc29uJyk7XG4gIHJldHVybiBKU09OLnBhcnNlKGF3YWl0IGZzLnJlYWRGaWxlKHJlY29tbWVuZGVkRmxhZ3NGaWxlLCB7IGVuY29kaW5nOiAndXRmLTgnIH0pKTtcbn1cbiJdfQ==